---
layout:     post
title:      iOS内存管理
subtitle:   底层原理、理解和探讨
date:       2021/11/15
author:     HongWeiChen
header-img: img/blog-banner-dark.jpg
catalog: true
tags:
    - iOS
---

在ObjC中，我们声明一个成员变量时，通常会有strong/weak/reatin/copy修饰符，而在Swift中，通常情况下是直接使用var来创建成员变量，某些特定情况下需要用weak来修饰，不加修饰符的成员变量为strong，若是在struct中创建成员变量，则是用copy。

**struct和class的区别可以参考我之前的blog**

不论是ObjC还是Swift，使用的内存管理技术都为ARC引用计数进行管理，通过retainCount来判断内存是否应该释放。

在ObjC中是没有unwoned的修饰符的，unowned在Swift中代表的是无主引用，其作用与assign、unsafe_unretained相似。其作用是引用对象指针，不会进行引用技术自增的处理，但是在引用对象被释放之后，其对象指针仍然指向引用对象指针，所以会导致野指针的问题。

所以一般情况下建议使用weak来作为弱引用的修饰，但是并非unowned就没有用武之地。

unowned相对于weak是有一定的优势的，由于unowned在引用对象被释放后不会执行释放动作，所以在引用对象被释放后不需要做一些额外的操作，若是确保unowned对象在引用对象被释放后不会被使用到，就可以使用unowned。

不论是weak还是unsafe_unretained或者unowned，其作用都是引用对象指针，不会进行引用计数自增的处理。

retain是MRC时代下的产物，在MRC与ARC的内存管理层面，retainCount会产生一些区别，具体区别可能需要实际代码来测试才能从中发现(也可能是自身不够了解，后续会研究下这块的相关知识)

strong是在ARC后产生的一个内存管理修饰符，其底层代码如下（参考objc4-818.2）

```C
void
objc_storeStrong(id *location, id obj)
{
    id prev = *location;
    if (obj == prev) {
        return;
    }
    objc_retain(obj);
    *location = obj;
    objc_release(prev);
}
```

retain新对象，重新赋值并且release旧对象。没有什么太复杂的调用，而objc_retain和objc_release底层的实现不在这次的了解范围内，下次说明。

weak的实现可以翻看我之前写的[iOS中weak的底层原理](https://hongweichen.github.io/2021/11/15/iOS中weak的底层原理/)

这里简要说一下weak和assign、unsafe_unretained、unowned的区别，之前提到了assign、unsafe_unretained、unowned在引用对象被释放了之后，仍然保存对象指针的地址，从而导致野指针，而weak在引用对象被释放了之后，会自动设置为nil，其底层调用代码如下（参考源码objc4-818.2）

```
// rdar://20206767
// return uintptr_t instead of bool so that the various raw-isa
// -release paths all return zero in eax
uintptr_t
objc_object::sidetable_release(bool locked, bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];

    bool do_dealloc = false;

    if (!locked) table.lock();
    auto it = table.refcnts.try_emplace(this, SIDE_TABLE_DEALLOCATING);
    auto &refcnt = it.first->second;
    if (it.second) {
        do_dealloc = true;
    } else if (refcnt < SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        do_dealloc = true;
        refcnt |= SIDE_TABLE_DEALLOCATING;
    } else if (! (refcnt & SIDE_TABLE_RC_PINNED)) {
        refcnt -= SIDE_TABLE_RC_ONE;
    }
    table.unlock();
    if (do_dealloc  &&  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));
    }
    return do_dealloc;
}
```
