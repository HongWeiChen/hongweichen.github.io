---
layout:     post
title:      iOS中weak的底层原理
subtitle:   iOS中weak的底层原理
date:       2021/11/12
author:     HongWeiChen
header-img: img/blog-banner-dark.jpg
catalog: true
tags:
    - Objective-C
---

# 前言

刚写过Swift中的内存管理，写到了weak和unowned，所以接下来想写一写iOS中weak的底层原理

# weak底层实现代码

# objc_initWeak

```
id
objc_initWeak(id *location, id newObj)
{
    // 如果newObject不存在 则设置weak指针为nil
    if (!newObj) {
        *location = nil;
        return nil;
    }
    // 具体实现
    return storeWeak<DontHaveOld, DoHaveNew, DoCrashIfDeallocating>
        (location, (objc_object*)newObj);
}
```

objc_initWeak方法只是一个入口，具体实现方法都在storeWeak当中，在weak第一次初始化时，会调用objc_initWeak方法

# objc_storeWeak

```
/**
 * This function stores a new value into a __weak variable. It would
 * be used anywhere a __weak variable is the target of an assignment.
 *
 * @param location The address of the weak pointer itself
 * @param newObj The new object this weak ptr should now point to
 *
 * @return \e newObj
 */
id
objc_storeWeak(id *location, id newObj)
{
    return storeWeak<DoHaveOld, DoHaveNew, DoCrashIfDeallocating>
        (location, (objc_object *)newObj);
}
```

当weak已初始化后，再更新weak值，则调用objc_storeWeak的方法

# storeWeak

```
/// 是否产生Crash
enum CrashIfDeallocating {
    DontCrashIfDeallocating = false, DoCrashIfDeallocating = true
};
/// 是否有旧值，是否有新值，模板传值
/// location是weak指针地址，newObj是新的指针地址
template <HaveOld haveOld, HaveNew haveNew,
          enum CrashIfDeallocating crashIfDeallocating>
static id
storeWeak(id *location, objc_object *newObj)
{
    // 前面基本是对传入值异常的判断 略过
    ASSERT(haveOld  ||  haveNew);
    if (!haveNew) ASSERT(newObj == nil);

    Class previouslyInitializedClass = nil;
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    // Acquire locks for old and new values.
    // Order by lock address to prevent lock ordering problems.
    // Retry if the old value changes underneath us.
    // retry是一个goto函数
 retry:
    // 如果有旧的值，将指针地址给到oldObj
    // 根据oldObj取到SideTables中对应的SideTable，SideTables是一个全局的数据
    // 没有旧的值则将oldTable设置为nil
    if (haveOld) {
        oldObj = *location;
        oldTable = &SideTables()[oldObj];
    } else {
        oldTable = nil;
    }
    // 如果有新的值，则尝试从SideTables中根据newObj取到SideTable
    // 预防SideTable已经存在的情况
    if (haveNew) {
        newTable = &SideTables()[newObj];
    } else {
        newTable = nil;
    }

    // 给oldTable和newTable上锁，避免资源竞争
    SideTable::lockTwo<haveOld, haveNew>(oldTable, newTable);

    // 如果有旧的值 但是location不等于oldObj，则解锁重新执行retry（可能被其他线程又修改了weak的值）
    if (haveOld  &&  *location != oldObj) {
        SideTable::unlockTwo<haveOld, haveNew>(oldTable, newTable);
        goto retry;
    }

    // Prevent a deadlock between the weak reference machinery
    // and the +initialize machinery by ensuring that no
    // weakly-referenced object has an un-+initialized isa.
    if (haveNew  &&  newObj) {
        Class cls = newObj->getIsa();
        // 初始化previouslyInitializedClass再设置weak
        if (cls != previouslyInitializedClass  &&  
            !((objc_class *)cls)->isInitialized())
        {
            // 防止死锁 unlock
            SideTable::unlockTwo<haveOld, haveNew>(oldTable, newTable);
            class_initialize(cls, (id)newObj);

            // If this class is finished with +initialize then we're good.
            // If this class is still running +initialize on this thread
            // (i.e. +initialize called storeWeak on an instance of itself)
            // then we may proceed but it will appear initializing and
            // not yet initialized to the check above.
            // Instead set previouslyInitializedClass to recognize it on retry.
            previouslyInitializedClass = cls;

            goto retry;
        }
    }

    // Clean up old value, if any.
    // 移除旧的值 如果有
    if (haveOld) {
        weak_unregister_no_lock(&oldTable->weak_table, oldObj, location);
    }

    // Assign new value, if any.
    // 设置新的值，如果有
    if (haveNew) {
        newObj = (objc_object *)
            weak_register_no_lock(&newTable->weak_table, (id)newObj, location,
                                  crashIfDeallocating ? CrashIfDeallocating : ReturnNilIfDeallocating);
        // weak_register_no_lock returns nil if weak store should be rejected

        // Set is-weakly-referenced bit in refcount table.
        if (!newObj->isTaggedPointerOrNil()) {
            newObj->setWeaklyReferenced_nolock();
        }

        // Do not set *location anywhere else. That would introduce a race.
        *location = (id)newObj;
    }
    else {
        // No new value. The storage is not changed.
    }
    // 完成 解锁
    SideTable::unlockTwo<haveOld, haveNew>(oldTable, newTable);

    // This must be called without the locks held, as it can invoke
    // arbitrary code. In particular, even if _setWeaklyReferenced
    // is not implemented, resolveInstanceMethod: may be, and may
    // call back into the weak reference machinery.
    // 调用obj上的_setWeaklyReferenced方法
    callSetWeaklyReferenced((id)newObj);

    return (id)newObj;
}
```

1. storeWeak接收了5个参数，是否有旧值，是否有新值，如果weak正在析构时是否产生崩溃
2. 如果haveOld是为true，则将location的值丢给oldObj，然后使用oldObj来从&SideTables中取值，给oldTable赋值
3. 使用newObj从&SideTables中取值，给newTable赋值
4. 给oldTable和newTable上锁，避免资源竞争
5. 判断oldObj是否等于location，如果不相等，则解锁后重新执行retry方法，因为可能在其他线程修改了weak的值
6. 判断previouslyInitializedClass是否初始化，如果没有初始化，则初始化previouslyInitializedClass
7. 调用weak_unregister_no_lock移除旧的值
8. 调用weak_register_no_lock注册新的值，并且改变location的值为newObj
9. 完成后解锁
10. 调用newObj的_setWeaklyReferenced方法
11. 返回新的值

# 参考

- [iOS底层原理：weak的实现原理](https://juejin.cn/post/6844904101839372295)
