{"title":"SwiftUI Comebine","date":"2021-11-04T16:00:00.000Z","date_formatted":{"ll":"Nov 5, 2021","L":"11/05/2021","MM-DD":"11-05"},"author":"HongWeiChen","link":"2021/11/05/2021-11-02-SwiftUI Combine","tags":["SwiftUI"],"updated":"2021-11-15T04:56:14.000Z","content":"<h1 id=\"comebine\">Comebine<a title=\"#comebine\" href=\"#comebine\"></a></h1>\n<ul>\n<li><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%93%8D%E5%BA%94%E7%BC%96%E7%A8%8B\">函数式响应编程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%89%B9%E6%80%A7\">特性</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">使用场景</a></li>\n<li><a href=\"#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\">核心概念</a></li>\n</ul>\n<h1 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h1>\n<h2 id=\"函数式响应编程\">函数式响应编程<a title=\"#函数式响应编程\" href=\"#函数式响应编程\"></a></h2>\n<p>函数式响应编程（Functional reactive programming）也称为数据流编程，基于函数式编程的概念上。函数式编程应用于元素列表（元素的转变加工），而函数相应应用于元素流（元素的转变加工、流的分割合并；</p>\n<p>一个随着时间处理数据的声明式的SwiftAPI</p>\n<h1 id=\"特性\">特性<a title=\"#特性\" href=\"#特性\"></a></h1>\n<p>将这些概念应用到Swift中只是Combine所做的一部分。Combine还可以通过加入控流(back-pressure)的概念扩展了函数响应式编程。控流是指控制接收和处理的信息的数量，这使得数据可控可取消的扩展概念得到更有效的实践。</p>\n<h1 id=\"使用场景\">使用场景<a title=\"#使用场景\" href=\"#使用场景\"></a></h1>\n<ul>\n<li>你可以对一个按钮进行设置，只有当输入值是有效，才可以使按钮可用</li>\n<li>执行一些异步操作（比如检查网络服务），并且利用返回值来更新内容</li>\n<li>用来对用户在文本框中的动态输入做出回应，并且根据用户输入的内容更新视图内容</li>\n</ul>\n<h1 id=\"核心概念\">核心概念<a title=\"#核心概念\" href=\"#核心概念\"></a></h1>\n<ul>\n<li>Publisher(发布者)</li>\n<li>Subscriber(订阅者)</li>\n<li>Operators(操作者)</li>\n<li>Subjects(对象)</li>\n</ul>\n<h1 id=\"operators\">Operators<a title=\"#operators\" href=\"#operators\"></a></h1>\n<h2 id=\"receive\">receive<a title=\"#receive\" href=\"#receive\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// Specifies the scheduler on which to receive elements from the publisher.</span><br><span class=\"line\">///</span><br><span class=\"line\">/// You use the ``Publisher/receive(on:options:)`` operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop. In contrast with ``Publisher/subscribe(on:options:)``, which affects upstream messages, ``Publisher/receive(on:options:)`` changes the execution context of downstream messages.</span><br><span class=\"line\">///</span><br><span class=\"line\">/// In the following example, the ``Publisher/subscribe(on:options:)`` operator causes `jsonPublisher` to receive requests on `backgroundQueue`, while the</span><br><span class=\"line\">/// ``Publisher/receive(on:options:)`` causes `labelUpdater` to receive elements and completion on `RunLoop.main`.</span><br><span class=\"line\">///</span><br><span class=\"line\">///     let jsonPublisher = MyJSONLoaderPublisher() // Some publisher.</span><br><span class=\"line\">///     let labelUpdater = MyLabelUpdateSubscriber() // Some subscriber that updates the UI.</span><br><span class=\"line\">///</span><br><span class=\"line\">///     jsonPublisher</span><br><span class=\"line\">///         .subscribe(on: backgroundQueue)</span><br><span class=\"line\">///         .receive(on: RunLoop.main)</span><br><span class=\"line\">///         .subscribe(labelUpdater)</span><br><span class=\"line\">///</span><br><span class=\"line\">///</span><br><span class=\"line\">/// Prefer ``Publisher/receive(on:options:)`` over explicit use of dispatch queues when performing work in subscribers. For example, instead of the following pattern:</span><br><span class=\"line\">///</span><br><span class=\"line\">///     pub.sink &#123;</span><br><span class=\"line\">///         DispatchQueue.main.async &#123;</span><br><span class=\"line\">///             // Do something.</span><br><span class=\"line\">///         &#125;</span><br><span class=\"line\">///     &#125;</span><br><span class=\"line\">///</span><br><span class=\"line\">/// Use this pattern instead:</span><br><span class=\"line\">///</span><br><span class=\"line\">///     pub.receive(on: DispatchQueue.main).sink &#123;</span><br><span class=\"line\">///         // Do something.</span><br><span class=\"line\">///     &#125;</span><br><span class=\"line\">///</span><br><span class=\"line\">///  &gt; Note: ``Publisher/receive(on:options:)`` doesn’t affect the scheduler used to call the subscriber’s ``Subscriber/receive(subscription:)`` method.</span><br><span class=\"line\">///</span><br><span class=\"line\">/// - Parameters:</span><br><span class=\"line\">///   - scheduler: The scheduler the publisher uses for element delivery.</span><br><span class=\"line\">///   - options: Scheduler options used to customize element delivery.</span><br><span class=\"line\">/// - Returns: A publisher that delivers elements using the specified scheduler.</span><br></pre></td></tr></table></figure>\n<p>使用receive可以更改下游消息执行的线程调度</p>\n<p>例如：<br>\nreceive(on: DispatchQueue.global())<br>\n下游操作符就会在全局子线程执行<br>\nreceive(on: DispatchQueue.main)<br>\n下游操作符就会在主子线程执行</p>\n<ul>\n<li>在调用assign时，记得调用receive(on: RunLoop.main)，保证在MainThread执行UI操作。否则会报以下错误。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[SwiftUI] Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</span><br></pre></td></tr></table></figure>\n","prev":{"title":"数据结构1.1.1","link":"2021/11/06/2021-11-06-数据结构 1.1.1"},"next":{"title":"SwiftUI State","link":"2021/11/05/2021-11-03-SwiftUI State"},"plink":"http://hongweichen.github.io/2021/11/05/2021-11-02-SwiftUI Combine/","toc":[{"id":"comebine","title":"Comebine","index":"1"},{"id":"概念","title":"概念","index":"2","children":[{"id":"函数式响应编程","title":"函数式响应编程","index":"2.1"}]},{"id":"特性","title":"特性","index":"3"},{"id":"使用场景","title":"使用场景","index":"4"},{"id":"核心概念","title":"核心概念","index":"5"},{"id":"operators","title":"Operators","index":"6","children":[{"id":"receive","title":"receive","index":"6.1"}]}],"reading_time":"678 words in 5 min"}