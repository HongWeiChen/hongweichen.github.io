{"title":"内存管理基础","date":"2022-03-03T16:00:00.000Z","date_formatted":{"ll":"Mar 4, 2022","L":"03/04/2022","MM-DD":"03-04"},"link":"2022/03/04/内存管理基础","tags":["内存管理"],"updated":"2022-03-04T10:25:40.800Z","content":"<h1 id=\"程序可执行文件的结构\">程序可执行文件的结构<a title=\"#程序可执行文件的结构\" href=\"#程序可执行文件的结构\"></a></h1>\n<p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是常量）大致可以分成下面几个部分：</p>\n<ul>\n<li><code>.data</code>：初始化了的全局变量和静态变量</li>\n<li><code>.bss</code>：即Block Started by Symbol，未初始化的全局变量和静态变量</li>\n<li><code>heap</code>：堆，使用malloc，realloc，和free函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>\n<li><code>stack</code>：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个scope的变量）也存放在栈中</li>\n</ul>\n<p>下面就各个分区具体解释以下：</p>\n<h1 id=\"data和bss区\">data和bss区<a title=\"#data和bss区\" href=\"#data和bss区\"></a></h1>\n<p>这两个区经常放在一起说，因为它们都是用来存储全局变量和静态变量的，区别在于data区存放的是初始化过的，bss区存放的是没有初始化过的，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int val = 3;</span><br><span class=\"line\">char string[] = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure>\n<p>这两个变量的<strong>值</strong>会一开始被存放在.text中（因为值是写在代码里的），在程序启动时会拷贝到.data去区中。<br>\n而不初始化的话，像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int i;</span><br></pre></td></tr></table></figure>\n<p>这个变量就会在bss区中。</p>\n<p><strong>答疑一</strong>静态变量和全局变量</p>\n<p>这两个概念都是很常见的概念，又经常在一起使用，很容易造成混淆。<br>\n<code>全局变量</code>：在一个代码文件（具体说应该一个<a href=\"https://en.wikipedia.org/wiki/Translation_unit_programming\" target=\"_blank\">translation unit/compilation unit</a>）当中，一个变量要么定义在函数中，要么定义在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做external linkage）。当有如下两个文件时：<br>\na.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int a;</span><br><span class=\"line\">int compute(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  a = 1;</span><br><span class=\"line\">  printf(&quot;%d %d\\n&quot;, a, compute());</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>b.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a;</span><br><span class=\"line\">int compute(void) &#123;</span><br><span class=\"line\">  a = 0;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Link过程中会产生重复定义错误，因为有两个全局的<code>a</code>变量，Linker不知道应该使用哪一个。为了避免这种情况，就需要引入static。<br>\n<code>静态变量</code>：指使用static关键字修饰的变量，static关键字对变量的作用域进行了限制，具体的限制如下：</p>\n<ul>\n<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做internal linkage）</li>\n<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）</li>\n<li>（C++）在类中定义：全局变量，但是只在此类中可见<br>\n对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用static，另一个不使用。这样使用static的就会使用自己的<code>a</code>变量，而没有用static的就会用全局的<code>a</code>变量。当然，最好两个都使用static，避免更多可能的命名冲突。</li>\n</ul>\n<p><em>注意</em>：'静态’这个中文翻译实在是有些莫名其妙，给人的感觉像是不可改变的，而实际上static跟不可改变没有关系，不可改变的变量使用const关键字修饰，注意不要混淆。</p>\n<p><em>Bonus部分 – extern</em>：extern是C语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用extern可以在多个源文件中共享某个变量，例如<a href=\"https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files\" target=\"_blank\">这里</a>的例子。extern跟static在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，有两种情况，一种先使用static，后使用extern，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int m;</span><br><span class=\"line\">extern int m;</span><br></pre></td></tr></table></figure>\n<p>这种情况，后面的m实际上就是前面的m。如果反过来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern int m;</span><br><span class=\"line\">static int m;</span><br></pre></td></tr></table></figure>\n<p>这种情况是未定义的，编译器也会给出警告。</p>\n<p><strong>答疑二</strong>程序在内存和硬盘上不同的存在形式</p>\n<p>这里我们提到几个区，是指程序在内存中的存在形式。和程序在硬盘上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考<a href=\"https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats\" target=\"_blank\">这里</a>。一个比较明显的例子可以帮你区分这个差别：之前我们提到过未定义的全局变量存在<code>.bss</code>区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成0，存储在内存中。</p>\n<h1 id=\"栈（stack）\">栈（Stack）<a title=\"#栈（stack）\" href=\"#栈（stack）\"></a></h1>\n<p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。</p>\n<p>栈是一块连续的内存区域，栈顶的地址和栈最大容量是系统预先规定好的。能从栈获得空间极小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。</p>\n<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，出栈压栈都有专门的指令执行，这就决定了栈的效率比较高。</p>\n<h1 id=\"堆（heap）\">堆（Heap）<a title=\"#堆（heap）\" href=\"#堆（heap）\"></a></h1>\n<p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用<code>malloc</code>和<code>free</code>时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>\n<p>堆是高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>\n<p>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。</p>\n<p>堆都是动态分配的，没有静态分配的堆。堆有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</p>\n<p>计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。</p>\n<h1 id=\"内存分配\">内存分配<a title=\"#内存分配\" href=\"#内存分配\"></a></h1>\n<ul>\n<li>虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称+段内相对地址构成，这样的程序地址称为虚拟地址</li>\n<li>逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址</li>\n<li>物理地址：实际物理内存中所看到的存储地址称为物理地址</li>\n<li>逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间</li>\n<li>线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间</li>\n<li>物理地址空间：实际存在的可访问的物理地址内存集合称为物理地址空间</li>\n<li>MMU（Memory Management Unit内存管理单元）：实现将用户程序的虚拟地址（逻辑地址）-&gt; 物理地址映射的CPU中的硬件电路</li>\n<li>基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算</li>\n<li>偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值</li>\n</ul>\n<p>虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理内存。</p>\n<h1 id=\"虚拟内存\">虚拟内存<a title=\"#虚拟内存\" href=\"#虚拟内存\"></a></h1>\n<ul>\n<li>请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入</li>\n</ul>\n<h1 id=\"页面置换算法\">页面置换算法<a title=\"#页面置换算法\" href=\"#页面置换算法\"></a></h1>\n<ul>\n<li>FIFO算法<br>\n先入先出，即淘汰最早调入的页面</li>\n<li>OPT（MIN）算法<br>\n选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。<br>\n可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</li>\n<li>LRU（Least-Recently-Used）算法<br>\n用过去的历史预测将来，选最近最长时间没有使用的页淘汰（也称最近最少使用）。<br>\nLRU精准实现：计数器法，页码栈法<br>\n由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。</li>\n</ul>\n<p><strong>内存抖动现象</strong>：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存算法不好，内存太小引起或者程序算法不佳引起的。<br>\n<strong>Belady现象</strong>：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。<br>\nFIFO会产生Belady异常。<br>\n栈式算法无Belady异常，LRU，LFU（最不常使用），OPT都属于栈是算法。</p>\n","next":{"title":"Objective-C之方法的本质","link":"2021/12/22/Objective-C之方法的本质"},"plink":"http://hongweichen.github.io/2022/03/04/内存管理基础/","toc":[{"id":"程序可执行文件的结构","title":"程序可执行文件的结构","index":"1"},{"id":"data和bss区","title":"data和bss区","index":"2"},{"id":"栈（stack）","title":"栈（Stack）","index":"3"},{"id":"堆（heap）","title":"堆（Heap）","index":"4"},{"id":"内存分配","title":"内存分配","index":"5"},{"id":"虚拟内存","title":"虚拟内存","index":"6"},{"id":"页面置换算法","title":"页面置换算法","index":"7"}],"reading_time":"2622 words in 17 min"}