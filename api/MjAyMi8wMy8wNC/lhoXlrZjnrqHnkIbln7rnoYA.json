{"title":"内存管理基础","date":"2022-03-03T16:00:00.000Z","date_formatted":{"ll":"Mar 4, 2022","L":"03/04/2022","MM-DD":"03-04"},"link":"2022/03/04/内存管理基础","tags":["内存管理"],"updated":"2022-03-04T08:18:23.738Z","content":"<h1 id=\"程序可执行文件的结构\">程序可执行文件的结构<a title=\"#程序可执行文件的结构\" href=\"#程序可执行文件的结构\"></a></h1>\n<p>一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是常量）大致可以分成下面几个部分：</p>\n<ul>\n<li><code>.data</code>：初始化了的全局变量和静态变量</li>\n<li><code>.bss</code>：即Block Started by Symbol，未初始化的全局变量和静态变量</li>\n<li><code>heap</code>：堆，使用malloc，realloc，和free函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用</li>\n<li><code>stack</code>：栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个scope的变量）也存放在栈中</li>\n</ul>\n<p>下面就各个分区具体解释以下：</p>\n<h1 id=\"data和bss区\">data和bss区<a title=\"#data和bss区\" href=\"#data和bss区\"></a></h1>\n<p>这两个区经常放在一起说，因为它们都是用来存储全局变量和静态变量的，区别在于data区存放的是初始化过的，bss区存放的是没有初始化过的，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int val = 3;</span><br><span class=\"line\">char string[] = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure>\n<p>这两个变量的<strong>值</strong>会一开始被存放在.text中（因为值是写在代码里的），在程序启动时会拷贝到.data去区中。<br>\n而不初始化的话，像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int i;</span><br></pre></td></tr></table></figure>\n<p>这个变量就会在bss区中。</p>\n<p><strong>答疑一</strong>静态变量和全局变量</p>\n<p>这两个概念都是很常见的概念，又经常在一起使用，很容易造成混淆。<br>\n<code>全局变量</code>：在一个代码文件（具体说应该一个[translation unit/compilation unit](<a href=\"https://en.wikipedia.org/wiki/Translation_unit_(programming)%EF%BC%89%E5%BD%93%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A6%81%E4%B9%88%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E8%A6%81%E4%B9%88%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A4%96%E9%9D%A2%E3%80%82%E5%BD%93%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A4%96%E9%9D%A2%E6%97%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%B0%B1%E6%9C%89%E4%BA%86%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E6%88%90%E4%B8%BA%E4%BA%86%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%82%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%89%E6%84%8F%E5%91%B3%E7%9D%80%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B9%9F%E6%84%8F%E5%91%B3%E7%9D%80%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%88%E8%BF%99%E7%A7%8D%E5%8F%AB%E5%81%9Aexternal\">https://en.wikipedia.org/wiki/Translation_unit_(programming)）当中，一个变量要么定义在函数中，要么定义在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做external</a> linkage）。当有如下两个文件时：<br>\na.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int a;</span><br><span class=\"line\">int compute(void);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  a = 1;</span><br><span class=\"line\">  printf(&quot;%d %d\\n&quot;, a, compute());</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>b.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a;</span><br><span class=\"line\">int compute(void) &#123;</span><br><span class=\"line\">  a = 0;</span><br><span class=\"line\">  return a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Link过程中会产生重复定义错误，因为有两个全局的<code>a</code>变量，Linker不知道应该使用哪一个。为了避免这种情况，就需要引入static。<br>\n<code>静态变量</code>：指使用static关键字修饰的变量，static关键字对变量的作用域进行了限制，具体的限制如下：</p>\n<ul>\n<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做internal linkage）</li>\n<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）</li>\n<li>（C++）在类中定义：全局变量，但是只在此类中可见<br>\n对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用static，另一个不使用。这样使用static的就会使用自己的<code>a</code>变量，而没有用static的就会用全局的<code>a</code>变量。当然，最好两个都使用static，避免更多可能的命名冲突。</li>\n</ul>\n<p><em>注意</em>：'静态’这个中文翻译实在是有些莫名其妙，给人的感觉像是不可改变的，而实际上static跟不可改变没有关系，不可改变的变量使用const关键字修饰，注意不要混淆。</p>\n<p><em>Bonus部分 – extern</em>：extern是C语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用extern可以在多个源文件中共享某个变量，例如<a href=\"https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files\" target=\"_blank\">这里</a>的例子。extern跟static在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，有两种情况，一种先使用static，后使用extern，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int m;</span><br><span class=\"line\">extern int m;</span><br></pre></td></tr></table></figure>\n<p>这种情况，后面的m实际上就是前面的m。如果反过来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern int m;</span><br><span class=\"line\">static int m;</span><br></pre></td></tr></table></figure>\n<p>这种情况是未定义的，编译器也会给出警告。</p>\n<p><strong>答疑二</strong>程序在内存和硬盘上不同的存在形式</p>\n<p>这里我们提到几个区，是指程序在内存中的存在形式。和程序在硬盘上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考<a href=\"https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats\" target=\"_blank\">这里</a>。一个比较明显的例子可以帮你区分这个差别：之前我们提到过未定义的全局变量存在<code>.bss</code>区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成0，存储在内存中。</p>\n<h1 id=\"栈（stack）\">栈（Stack）<a title=\"#栈（stack）\" href=\"#栈（stack）\"></a></h1>\n<p>栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。</p>\n<p>栈是一块连续的内存区域，栈顶的地址和栈最大容量是系统预先规定好的。能从栈获得空间极小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。</p>\n<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，出栈压栈都有专门的指令执行，这就决定了栈的效率比较高。</p>\n<h1 id=\"堆（heap）\">堆（Heap）<a title=\"#堆（heap）\" href=\"#堆（heap）\"></a></h1>\n<p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用<code>malloc</code>和<code>free</code>时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>\n<p>堆是高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>\n","next":{"title":"Objective-C之方法的本质","link":"2021/12/22/Objective-C之方法的本质"},"plink":"http://hongweichen.github.io/2022/03/04/内存管理基础/","toc":[{"id":"程序可执行文件的结构","title":"程序可执行文件的结构","index":"1"},{"id":"data和bss区","title":"data和bss区","index":"2"},{"id":"栈（stack）","title":"栈（Stack）","index":"3"},{"id":"堆（heap）","title":"堆（Heap）","index":"4"}],"reading_time":"1690 words in 11 min"}