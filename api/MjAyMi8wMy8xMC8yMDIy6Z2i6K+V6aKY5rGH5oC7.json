{"title":"2022面试题汇总","date":"2022-03-09T16:00:00.000Z","date_formatted":{"ll":"Mar 10, 2022","L":"03/10/2022","MM-DD":"03-10"},"link":"2022/03/10/2022面试题汇总","tags":["面试题"],"updated":"2022-03-15T04:04:20.843Z","content":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>有任何问题可以给我发送邮箱或者Github给我提交PR。</p>\n<h1 id=\"目录\">目录<a title=\"#目录\" href=\"#目录\"></a></h1>\n<ul>\n<li><a href=\"#block\">Block</a>\n<ul>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9F\">如何避免循环引用？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BF%AE%E9%A5%B0%E7%AC%A6\">修饰符</a>\n<ul>\n<li><a href=\"#__weak%E5%92%8C__block%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">__weak和__block的区别？</a></li>\n<li><a href=\"#open%E5%92%8Cpublic%E5%8C%BA%E5%88%AB%EF%BC%9F\">open和public区别？</a></li>\n<li><a href=\"#swift%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">Swift定义常量关键字，有什么区别？</a></li>\n</ul>\n</li>\n<li><a href=\"#kvc%E5%92%8Ckvo\">KVC、KVO</a>\n<ul>\n<li><a href=\"#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9kvc%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">谈谈你对KVC的理解？</a></li>\n<li><a href=\"#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9kvo%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">谈谈你对KVO的理解？</a></li>\n</ul>\n</li>\n<li><a href=\"#runtime\">Runtime</a>\n<ul>\n<li><a href=\"#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9runtime%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">谈谈你对Runtime的理解？</a></li>\n<li><a href=\"#sel%E5%92%8Cimp%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">SEL和IMP是什么？</a></li>\n<li><a href=\"#runtime%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9Fruntime%E5%85%B7%E4%BD%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F\">Runtime你用过哪些方法？Runtime具体有什么用？</a></li>\n</ul>\n</li>\n<li><a href=\"#runloop\">Runloop</a>\n<ul>\n<li><a href=\"#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9runloop%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">谈谈你对Runloop的理解？</a></li>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E5%92%8Crunloop%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F\">线程和Runloop之间的关系？</a></li>\n<li><a href=\"#runloop%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8Dmode%EF%BC%9F\">Runloop有哪几种Mode？</a></li>\n</ul>\n</li>\n<li><a href=\"#uiview%E5%92%8Ccalayer%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F\">UIView和CALayer的关系？</a></li>\n<li>[Swift 逃逸闭包、非逃逸闭包](#swift 逃逸闭包、非逃逸闭包)</li>\n<li><a href=\"#%60inout%60%E5%8F%82%E6%95%B0\"><code>inout</code>参数</a></li>\n<li><a href=\"#%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93\">离屏渲染</a>\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9F\">什么是离屏渲染？</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%BF%E5%85%8D%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9F\">为什么要避免离屏渲染？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9F\">如何避免离屏渲染？</a>\n<ul>\n<li><a href=\"#%E9%98%B4%E5%BD%B1\">阴影</a></li>\n<li><a href=\"#%E5%9C%86%E8%A7%92\">圆角</a></li>\n<li><a href=\"#mask%EF%BC%88%E9%81%AE%E7%BD%A9%EF%BC%89\">mask（遮罩）</a></li>\n<li><a href=\"#allowsgroupopacity%EF%BC%88%E7%BB%84%E4%B8%8D%E9%80%8F%E6%98%8E%EF%BC%89\">allowsGroupOpacity（组不透明）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%EF%BC%9F\">如何监测离屏渲染？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F\">什么是泛型？</a>\n<ul>\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0\">泛型函数</a></li>\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B\">泛型类型</a></li>\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\">泛型约束</a></li>\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E5%8D%8F%E8%AE%AE\">泛型协议</a></li>\n</ul>\n</li>\n<li><a href=\"#http%E5%92%8Chttps\">HTTP和HTTPS</a>\n<ul>\n<li><a href=\"#http%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B\">HTTP的请求过程</a></li>\n<li><a href=\"#https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%9F\">HTTPS加密过程？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98\">英文面试题</a></li>\n</ul>\n<h1 id=\"block\">block<a title=\"#block\" href=\"#block\"></a></h1>\n<h2 id=\"如何避免循环引用？\">如何避免循环引用？<a title=\"#如何避免循环引用？\" href=\"#如何避免循环引用？\"></a></h2>\n<p>使用<code>weak</code>来持有对象。</p>\n<h1 id=\"修饰符\">修饰符<a title=\"#修饰符\" href=\"#修饰符\"></a></h1>\n<h2 id=\"__weak和__block的区别？\">__weak和__block的区别？<a title=\"#__weak和__block的区别？\" href=\"#__weak和__block的区别？\"></a></h2>\n<ol>\n<li><code>__block</code>不管是ARC还是MRC都可以使用，<code>__weak</code>只可以在ARC下使用</li>\n<li><code>__block</code>可以修饰基本数据类型，<code>__weak</code>只能修饰对象</li>\n<li><code>__block</code>对象可以在<code>__block</code>中重新被赋值，<code>__weak</code>对象不可以重新被赋值</li>\n<li><code>__block</code>会持有该对象，即使超出了该对象的作用域，该对象还是会存在，直到<code>block</code>对象从堆上销毁。<code>__weak</code>仅仅只是将该对象的值赋给<code>weak</code>对象，当该对象销毁时，<code>weak</code>对象指向nil。</li>\n</ol>\n<h2 id=\"open和public区别？\">open和public区别？<a title=\"#open和public区别？\" href=\"#open和public区别？\"></a></h2>\n<ol>\n<li><code>public</code>修饰<code>class</code>只允许外部模块调用，但是不允许继承。而<code>open</code>修饰的<code>class</code>既允许外部调用，也允许被子类继承。</li>\n<li><code>public</code>修饰的成员只允许其他模块调用，但是不能被覆盖（override）。而<code>open</code>修饰的成员既允许被其他模块覆盖，也允许成员被覆盖。</li>\n<li>如果<code>class</code>声明为<code>public</code>，那么<code>class</code>成员变量不可以为<code>open</code>，因为<code>public class</code>已被限定为不可继承。</li>\n</ol>\n<h1 id=\"swift定义常量关键字，有什么区别？\">swift定义常量关键字，有什么区别？<a title=\"#swift定义常量关键字，有什么区别？\" href=\"#swift定义常量关键字，有什么区别？\"></a></h1>\n<p>Objective-C中<code>const</code>是用来表示常量的，而Swift中<code>let</code>不是用来表示常量的。<br>\nOjbective-C中<code>const</code>表明的常量类型和数值是在<code>compilation time</code>时编译时确定的，而Swift中<code>let</code>只是表明常量（只可以赋值一次），其类型和值既可以是静态的，也可以是一个动态的计算方法，它们在<code>runtime</code>运行时确定。</p>\n<h1 id=\"kvc和kvo\">kvc和kvo<a title=\"#kvc和kvo\" href=\"#kvc和kvo\"></a></h1>\n<h2 id=\"谈谈你对kvc的理解？\">谈谈你对kvc的理解？<a title=\"#谈谈你对kvc的理解？\" href=\"#谈谈你对kvc的理解？\"></a></h2>\n<p><strong>KVC</strong>可以通过<code>key</code>直接访问对象的属性，或者给对象的属性赋值，这样可以在运行时动态的访问或修改对象的属性。<br>\n当调用<code>setValue:forKey</code>时，底层会调用<strong>setter</strong>方法，如果没有找到<strong>setter</strong>方法，KVC机制会检查+ <code>(BOOL)accessInstanceVariablesDirectly</code>方法有没有返回<strong>YES</strong>，默认该方法返回<strong>YES</strong>，如果重写了该方法返回<strong>NO</strong>，那么在这一步会执行<code>setValue:forUndefinedKey:</code>方法，不过一般不会这么做，所以KVC会检索该类里面有没有对应的setter方法或成员变量。<br>\n如果该类没有<code>setter</code>方法，也没有对应的下划线成员变量，KVC机制会搜索is开头的成员变量。<br>\n如果以上方法都查找不到或者不存在，系统将会执行<code>setValue:forUndefinedKey</code>方法，默认抛出异常。<br>\n当调用<code>valueForKey:</code>时，KVC对key搜索方式不同于<code>setValue:forKey</code>。<br>\n首先按照getKey，key，isKey的顺序方法查找getter方法，找到的话就直接调用。如果是BOOL和Int等值的类型，会将其包装成一个NSNumber类型的对象。</p>\n<h2 id=\"谈谈你对kvo的理解？\">谈谈你对kvo的理解？<a title=\"#谈谈你对kvo的理解？\" href=\"#谈谈你对kvo的理解？\"></a></h2>\n<p><strong>KVO</strong>，即是<strong>key-value-obseving</strong>，利用一个Key来找到某个属性并监听其值的改变。在iOS中使用<code>addObserver:forKeyPath:options:context:</code>来监听一个对象的属性，并且实现对应的回调方法，<code>observeValueForKeyPath:ofObject:change:context</code>。</p>\n<p><strong>KVO</strong>的底层实现是当一个类的属性被观察时，系统会通过runtime动态创建一个派生类，并且会在这个类中重写基类被观察的属性setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用派生类的setter方法。</p>\n<h1 id=\"runtime\">Runtime<a title=\"#runtime\" href=\"#runtime\"></a></h1>\n<h2 id=\"谈谈你对runtime的理解？\">谈谈你对Runtime的理解？<a title=\"#谈谈你对runtime的理解？\" href=\"#谈谈你对runtime的理解？\"></a></h2>\n<p>Runtime是Objective-C区别与C语言这样的静态语言的一个非常重要的特性。对于C语言函数的调用会在编译时期就决定好，在编译完成后直接顺序执行。但是OC是一门动态语言，函数调用变成了消息发送，在编译期不能知道要调用哪个函数。所以Runtime无非就是去解决如何在运行时期找到调用方法这样的问题。</p>\n<h2 id=\"runtime是如何进行消息转发（发送）的？ios中消息传递机制是怎样的？\">Runtime是如何进行消息转发（发送）的？iOS中消息传递机制是怎样的？<a title=\"#runtime是如何进行消息转发（发送）的？ios中消息传递机制是怎样的？\" href=\"#runtime是如何进行消息转发（发送）的？ios中消息传递机制是怎样的？\"></a></h2>\n<p>当一个对象调用函数<code>[object foo];</code>的时候，实际上是调用了runtime的<code>objc_msgSend</code>函数，<code>objc_msgSend</code>函数有两个参数，方法接收者和方法的主体。当我们调用了一个方法的时候，<code>objc_msgSend</code>会先从<code>cache_t</code>缓存列表中查找到对应的<code>bucket</code>，然后从<code>bucket</code>中取到对应的<code>sel</code>和<code>imp</code>，<code>sel</code>是方法编号，<code>imp</code>是函数指针地址，从缓存中获取对应的<code>bucket</code>是汇编层面的快速查找。若快速查找找不到对应的方法，则开始慢速查找，也就是遍历查找，遍历方法列表<code>method_list</code>，若找不到就去父类查找，最终一直到<code>NSObject</code>，若一直都找不到的话，因为iOS有<strong>多态</strong>的特性，还会从分类中查找，若还是没有找到对应的方法就只能进入消息转发的方法中，消息转发也分为快速转发和慢速转发，<code>forwardingTargetForSelector</code>和<code>methodSignatureForSelector</code>，这两个方法顺序执行，如果还没有找到就只能崩溃退出App程序。</p>\n<h2 id=\"sel和imp是什么？\">SEL和IMP是什么？<a title=\"#sel和imp是什么？\" href=\"#sel和imp是什么？\"></a></h2>\n<p><code>SEL</code>是方法编号，<code>IMP</code>是函数指针地址。</p>\n<h2 id=\"runtime你用过哪些方法？runtime具体有什么用？\">Runtime你用过哪些方法？Runtime具体有什么用？<a title=\"#runtime你用过哪些方法？runtime具体有什么用？\" href=\"#runtime你用过哪些方法？runtime具体有什么用？\"></a></h2>\n<ol>\n<li>利用关联对象，给分类增加属性</li>\n<li>遍历类的所有成员变量</li>\n<li>方法交换</li>\n<li>利用消息转发机制解决方法找不到的异常问题</li>\n</ol>\n<h1 id=\"runloop\">Runloop<a title=\"#runloop\" href=\"#runloop\"></a></h1>\n<h2 id=\"谈谈你对runloop的理解？\">谈谈你对Runloop的理解？<a title=\"#谈谈你对runloop的理解？\" href=\"#谈谈你对runloop的理解？\"></a></h2>\n<p>Runloop是一种循环，只不过它这种循环比较高级。一般的while循环会导致CPU进入忙等待状态，而Runloop则是一种“闲”等待，这部分可以类比Linux下的epoll。当没有事件时，Runloop会进入休眠状态，有事件发生时，Runloop会去找对应Handler处理事件。Runloop可以让线程在需要做事的时候忙起来，不需要的时候就让线程休眠。</p>\n<h2 id=\"线程和runloop之间的关系？\">线程和Runloop之间的关系？<a title=\"#线程和runloop之间的关系？\" href=\"#线程和runloop之间的关系？\"></a></h2>\n<p>Runloop和线程是绑定在一起。每个线程（包括主线程）都有一个对应的Runloop对象。我们并不能自己创建Runloop对象，但是可以获取到系统提供的Runloop对象。</p>\n<h2 id=\"runloop有哪几种mode？\">Runloop有哪几种Mode？<a title=\"#runloop有哪几种mode？\" href=\"#runloop有哪几种mode？\"></a></h2>\n<ul>\n<li><code>NSDefaultRunLoopMode</code></li>\n<li><code>NSConnectionReplyMode</code></li>\n<li><code>NSModalPanelRunLoopMode</code></li>\n<li><code>NSEventTrackingRunLoopMode</code></li>\n<li><code>NSRunLoopCommonModes</code><br>\niOS中公开暴露出来的只有<code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>。<br>\n<code>NSRunLoopCommonModes</code>实际上是一个Mode的集合，默认包括<code>NSDefaultRunLoopMode</code>和<code>NSEventTrackingRunLoopMode</code>。</li>\n</ul>\n<h1 id=\"uiview和calayer的关系？\">UIView和CALayer的关系？<a title=\"#uiview和calayer的关系？\" href=\"#uiview和calayer的关系？\"></a></h1>\n<p>CALayer基于Quartz框架，而UIView基于UIKit框架。</p>\n<p>从父类来说，使用CALayer同样可以实现UIImageView一样的展示效果，CALayer是继承自NSObject的，而UIView是继承自UIResponder的。所以相对于CALayer来说，UIView多了一个事件处理功能，也就是说，CALayer是不能处理用户触摸的。</p>\n<p>如果展示的视图不需要手势处理事件，可以考虑使用CALayer，因为CALayer的性能相比于UIView来说要好得多。</p>\n<h1 id=\"swift-逃逸闭包、非逃逸闭包\">Swift 逃逸闭包、非逃逸闭包<a title=\"#swift-逃逸闭包、非逃逸闭包\" href=\"#swift-逃逸闭包、非逃逸闭包\"></a></h1>\n<p>一个接受闭包作为参数的函数，该闭包可能在函数返回后才被调用，也就是说这个闭包逃离了该函数的作用域，这种闭包称为逃逸闭包。当你声明一个接受闭包作为参数的函数时，你可以在形式参数前写<code>@escaping</code>来明确逃逸闭包是允许逃逸。而非逃逸闭包作为参数的函数时，在函数返回之前调用该闭包。</p>\n<h1 id=\"inout参数\"><code>inout</code>参数<a title=\"#inout参数\" href=\"#inout参数\"></a></h1>\n<p>函数中传入的参数只需对参数进行修改，使用<code>inout</code>进行表示，调用函数需要添加&amp;。</p>\n<h1 id=\"离屏渲染\">离屏渲染<a title=\"#离屏渲染\" href=\"#离屏渲染\"></a></h1>\n<h2 id=\"什么是离屏渲染？\">什么是离屏渲染？<a title=\"#什么是离屏渲染？\" href=\"#什么是离屏渲染？\"></a></h2>\n<p>离屏渲染就是在当前屏幕缓冲区意以外，开辟一个新的缓冲区进行操作，触发的场景有，<em>圆角</em>，<em>涂层蒙板</em>，<em>阴影</em>，<em>光栅化</em>。</p>\n<h2 id=\"为什么要避免离屏渲染？\">为什么要避免离屏渲染？<a title=\"#为什么要避免离屏渲染？\" href=\"#为什么要避免离屏渲染？\"></a></h2>\n<p>因为离屏渲染会造成卡顿，CPU和GPU在绘制渲染视图时做了大量的工作。离屏渲染是发生在GPU层面上的，会创建新的渲染缓冲区，会触发<code>OpenGL</code>的多通道渲染管线，图形上下文的切换会造成额外的开销，增加GPU工作量。如果CPU和GPU累积<strong>16.67</strong>毫秒还没有完成，就会造成卡帧现象。</p>\n<h2 id=\"如何避免离屏渲染？\">如何避免离屏渲染？<a title=\"#如何避免离屏渲染？\" href=\"#如何避免离屏渲染？\"></a></h2>\n<p>造成离屏渲染主要有以下属性：<a href=\"#%E9%98%B4%E5%BD%B1\">阴影</a>、<a href=\"#%E5%9C%86%E8%A7%92\">圆角</a>、<a href=\"#mask%EF%BC%88%E9%81%AE%E7%BD%A9%EF%BC%89\">mask（遮罩）</a>、<a href=\"#allowsgroupopacity%EF%BC%88%E7%BB%84%E4%B8%8D%E9%80%8F%E6%98%8E%EF%BC%89\">allowsGroupOpacity（组不透明）</a></p>\n<h4 id=\"阴影\">阴影<a title=\"#阴影\" href=\"#阴影\"></a></h4>\n<p>使用<code>UIBezierPath</code>设置阴影，可以避免离屏渲染</p>\n<h4 id=\"圆角\">圆角<a title=\"#圆角\" href=\"#圆角\"></a></h4>\n<p>圆角图片在后台进行进行绘制，前台进行设置，可以避免离屏渲染</p>\n<h4 id=\"mask（遮罩）\">mask（遮罩）<a title=\"#mask（遮罩）\" href=\"#mask（遮罩）\"></a></h4>\n<p>不使用mask，使用混合图层，构建一个<code>subLayer</code>，并且给<code>subLayer</code>设置一个<code>content</code>，添加到对应内容控件上</p>\n<h4 id=\"allowsgroupopacity（组不透明）\">allowsGroupOpacity（组不透明）<a title=\"#allowsgroupopacity（组不透明）\" href=\"#allowsgroupopacity（组不透明）\"></a></h4>\n<p>不使用<code>allowsGroupOpacity</code>，根据产品要求控制layer透明度。</p>\n<h2 id=\"如何监测离屏渲染？\">如何监测离屏渲染？<a title=\"#如何监测离屏渲染？\" href=\"#如何监测离屏渲染？\"></a></h2>\n<p>模拟器 -&gt; debug -&gt; 选取Color Offscreen-Rendered</p>\n<h1 id=\"什么是泛型？\">什么是泛型？<a title=\"#什么是泛型？\" href=\"#什么是泛型？\"></a></h1>\n<p>泛型的使用分为：<a href=\"#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0\">泛型函数</a>、<a href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B\">泛型类型</a>、<a href=\"#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\">泛型约束</a>、<a href=\"#%E6%B3%9B%E5%9E%8B%E5%8D%8F%E8%AE%AE\">泛型协议</a>。</p>\n<h2 id=\"泛型函数\">泛型函数<a title=\"#泛型函数\" href=\"#泛型函数\"></a></h2>\n<p>指的是函数参数或返回值类型用泛型表示</p>\n<h2 id=\"泛型类型\">泛型类型<a title=\"#泛型类型\" href=\"#泛型类型\"></a></h2>\n<p>在定义类型时，使用泛型限制数据类型</p>\n<h2 id=\"泛型约束\">泛型约束<a title=\"#泛型约束\" href=\"#泛型约束\"></a></h2>\n<p>泛型约束分为<strong>继承约束</strong>、<strong>协议约束</strong>、<strong>条件约束</strong>。<br>\n继承约束指的是泛型类型必须是某个类的子类类型，协议约束指的是泛型类型必须遵循某些协议，条件约束泛型必须满足某种条件。</p>\n<h2 id=\"泛型协议\">泛型协议<a title=\"#泛型协议\" href=\"#泛型协议\"></a></h2>\n<p>泛型协议则是为协议添加泛型，使得协议可以传入类型限制协议类型。</p>\n<h1 id=\"http和https\">HTTP和HTTPS<a title=\"#http和https\" href=\"#http和https\"></a></h1>\n<h2 id=\"http的请求过程\">HTTP的请求过程<a title=\"#http的请求过程\" href=\"#http的请求过程\"></a></h2>\n<p>HTTP请求过程指的是三次握手和四次挥手</p>\n<p>所谓三次握手（Three-way Handshake），是指建立一个TCP连接时，需要客户端和服务器总共发送三个包。<br>\n三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息，在socket编程中，客户端执行connect()时。将触发三次握手。</p>\n<ul>\n<li>\n<p>第一次握手（SYN=1，seq=x）：<br>\n客户端发送一个TCP和SYN标志位置1的包，指明客户端打算连接服务器的端口，以及初始序列号x，保存在包头的序列号（Sequence Number）字段里面。</p>\n</li>\n<li>\n<p>第二次握手（SYN=1，ACK=1，seq=y，ACKnum=x+1）：<br>\n服务器发回确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器选择自己的ISN序列号，放到Seq域里面，同时将确认序列号（Acknowleagement Number）设置客户端的ISN加1，即X+1。发送完毕后，服务端进入SEND_RCVD状态。</p>\n</li>\n<li>\n<p>第三次握手（ACK=1，ACKnum=y+1）<br>\n客户端再次发送确认包（ACK），SYN标志位为0，ACK标志位为1，并且把服务器发来的ACK的序列号字段+1，放在确认字段中发送给对方，并且在数据段放写ISN+1<br>\n发送完毕后，客户端进入ESTABLISHED状态，当服务器接收到这个包时，也就进入了ESTABLISHED状态，TCP握手结束。</p>\n</li>\n</ul>\n<p>TCP的连接拆除需要发送四个包，因此称为四次挥手（Four-way Handshake），也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>\n<ul>\n<li>\n<p>第一次挥手（FIN=1，seq=x）<br>\n假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍可以接收数据。<br>\n发送完毕后，客户端进入FIN_WAIT_1状态。</p>\n</li>\n<li>\n<p>第二次挥手（ACK=1，ACKnum=x+1）<br>\n服务端确认客户端的FIN包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接<br>\n发送完毕后，服务器进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器关闭连接。</p>\n</li>\n<li>\n<p>第三次挥手（FIN=1，seq=y）<br>\n服务器端准备好关闭连接时，向客户端发送结束连接连接请求，FIN置为1。<br>\n发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端最后一个ACK。</p>\n</li>\n<li>\n<p>第四次挥手（ACK=1，ACKnum=y+1）<br>\n客户端接收到来自服务器的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。<br>\n服务器接收到这个确认包之后，关闭连接，进入CLOSE状态。<br>\n客户端等待了某个固定时间（两个最大段的生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSE状态。</p>\n</li>\n</ul>\n<h2 id=\"https加密过程？\">HTTPS加密过程？<a title=\"#https加密过程？\" href=\"#https加密过程？\"></a></h2>\n<ol>\n<li>HTTP是HTTP over TLS，是一种在加密信道进行HTTP内容传输的协议。客户端发送一个消息到服务器，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。服务器端向客户端返回一个消息，消息中包含了服务器端的TLS版本，服务器所选择的加密算法，以及数字证书认证机构签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围，用于客户端验证身份。</li>\n<li>客户端根据自己的信任CA列表，验证服务端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称加密。</li>\n<li>服务端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥。</li>\n<li>客户端发送一个finished消息给服务端，使用对称密钥加密这次通讯的一个散列值</li>\n<li>服务器端生成自己的hash值，然后解密客户端发来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个finished消息，也使用协商好的对称密钥加密</li>\n<li>接下来整个TLS会话都会使用对称密钥进行加密，传输HTTP应用层内容。</li>\n</ol>\n<h1 id=\"敏捷开发\">敏捷开发<a title=\"#敏捷开发\" href=\"#敏捷开发\"></a></h1>\n<h2 id=\"什么是敏捷开发？\">什么是敏捷开发？<a title=\"#什么是敏捷开发？\" href=\"#什么是敏捷开发？\"></a></h2>\n<p>百度</p>\n<h2 id=\"有没有参与过敏捷开发的会议？\">有没有参与过敏捷开发的会议？<a title=\"#有没有参与过敏捷开发的会议？\" href=\"#有没有参与过敏捷开发的会议？\"></a></h2>\n<p>无</p>\n<h1 id=\"ios线程\">iOS线程<a title=\"#ios线程\" href=\"#ios线程\"></a></h1>\n<h2 id=\"nsoperation\">NSOperation<a title=\"#nsoperation\" href=\"#nsoperation\"></a></h2>\n<h2 id=\"gcd\">GCD<a title=\"#gcd\" href=\"#gcd\"></a></h2>\n<h2 id=\"nsthread\">NSThread<a title=\"#nsthread\" href=\"#nsthread\"></a></h2>\n<h1 id=\"单元测试\">单元测试<a title=\"#单元测试\" href=\"#单元测试\"></a></h1>\n<h2 id=\"xctest\">XCTest<a title=\"#xctest\" href=\"#xctest\"></a></h2>\n<h1 id=\"英文面试题\">英文面试题<a title=\"#英文面试题\" href=\"#英文面试题\"></a></h1>\n<h1 id=\"do-you-have-any-hobbies?你有什么爱好\">Do you have any hobbies?你有什么爱好<a title=\"#do-you-have-any-hobbies?你有什么爱好\" href=\"#do-you-have-any-hobbies?你有什么爱好\"></a></h1>\n<p>喜欢编程和旅行，编程是我的工作，同时我也非常喜欢它，我喜欢编程给我带来的成就感和编码规范带来的舒适感，而在平时工作之余，我则会选择旅行让我放松，去过重庆、上海、成都和武汉。</p>\n<blockquote>\n<p>I like programming and traveling. Programming is my job, and I also like it very much. I like the sense of achievement and comfort brought by coding standards from programming.</p>\n</blockquote>\n<h1 id=\"why-did-you-choose-us?你为什么选择我们？\">Why did you choose us?你为什么选择我们？<a title=\"#why-did-you-choose-us?你为什么选择我们？\" href=\"#why-did-you-choose-us?你为什么选择我们？\"></a></h1>\n<p>因为你们是一家重视技术，并且发展前景我非常看好。我感觉我的技术能力可以在这里得到重视和发挥，非常期待可以加入与您一起共事。</p>\n<blockquote>\n<p>Because you are a company that attaches great importance to technology, and I am very optimistic about its development prospects. I feel that my technical ability can be valued and played here, and I am looking forward to working with you.</p>\n</blockquote>\n<h1 id=\"what-is-your-greatest-strength?-你最大的优点是什么?\">What is your greatest strength? 你最大的优点是什么?<a title=\"#what-is-your-greatest-strength?-你最大的优点是什么?\" href=\"#what-is-your-greatest-strength?-你最大的优点是什么?\"></a></h1>\n<p>有责任心，自学能力较强，能够不断的丰富自己的知识体系，并且有丰富的App开发经验</p>\n<p>Responsible, strong self-learning ability, able to continuously enrich their knowledge system, and have rich experience in app development</p>\n<h1 id=\"简短的自我介绍\">简短的自我介绍<a title=\"#简短的自我介绍\" href=\"#简短的自我介绍\"></a></h1>\n<ol>\n<li>\n<p>Hi, my name is xxx，it is really a great honor to have this opprtunity to perticipate this interview，i would like to answer whatever you may raise，and i hope i can make a good performance today，eventually obtain the opportunity to enroll in。</p>\n</li>\n<li>\n<p>Hello, my name is xxx, I am from Zhangzhou, Fujian, I have worked in Xiamen for 4 years and Wuhan for 3 years. I have always been engaged in iOS App development, and have been exposed to the mixed development model of React-Native and Flutter. , and I have independently write Android applications. I have a strong learning ability and can integrate into the team very quickly. I look forward to joining and working with you.</p>\n</li>\n</ol>\n","next":{"title":"Objective-C 内存管理","link":"2022/03/05/Objective-C 内存管理"},"plink":"http://hongweichen.github.io/2022/03/10/2022面试题汇总/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"目录","title":"目录","index":"2"},{"id":"block","title":"block","index":"3","children":[{"id":"如何避免循环引用？","title":"如何避免循环引用？","index":"3.1"}]},{"id":"修饰符","title":"修饰符","index":"4","children":[{"id":"__weak和__block的区别？","title":"__weak和__block的区别？","index":"4.1"},{"id":"open和public区别？","title":"open和public区别？","index":"4.2"}]},{"id":"swift定义常量关键字，有什么区别？","title":"swift定义常量关键字，有什么区别？","index":"5"},{"id":"kvc和kvo","title":"kvc和kvo","index":"6","children":[{"id":"谈谈你对kvc的理解？","title":"谈谈你对kvc的理解？","index":"6.1"},{"id":"谈谈你对kvo的理解？","title":"谈谈你对kvo的理解？","index":"6.2"}]},{"id":"runtime","title":"Runtime","index":"7","children":[{"id":"谈谈你对runtime的理解？","title":"谈谈你对Runtime的理解？","index":"7.1"},{"id":"runtime是如何进行消息转发（发送）的？ios中消息传递机制是怎样的？","title":"Runtime是如何进行消息转发（发送）的？iOS中消息传递机制是怎样的？","index":"7.2"},{"id":"sel和imp是什么？","title":"SEL和IMP是什么？","index":"7.3"},{"id":"runtime你用过哪些方法？runtime具体有什么用？","title":"Runtime你用过哪些方法？Runtime具体有什么用？","index":"7.4"}]},{"id":"runloop","title":"Runloop","index":"8","children":[{"id":"谈谈你对runloop的理解？","title":"谈谈你对Runloop的理解？","index":"8.1"},{"id":"线程和runloop之间的关系？","title":"线程和Runloop之间的关系？","index":"8.2"},{"id":"runloop有哪几种mode？","title":"Runloop有哪几种Mode？","index":"8.3"}]},{"id":"uiview和calayer的关系？","title":"UIView和CALayer的关系？","index":"9"},{"id":"swift-逃逸闭包、非逃逸闭包","title":"Swift 逃逸闭包、非逃逸闭包","index":"10"},{"id":"inout参数","title":"inout参数","index":"11"},{"id":"离屏渲染","title":"离屏渲染","index":"12","children":[{"id":"什么是离屏渲染？","title":"什么是离屏渲染？","index":"12.1"},{"id":"为什么要避免离屏渲染？","title":"为什么要避免离屏渲染？","index":"12.2"},{"id":"如何避免离屏渲染？","title":"如何避免离屏渲染？","index":"12.3"},{"id":"如何监测离屏渲染？","title":"如何监测离屏渲染？","index":"12.4"}]},{"id":"什么是泛型？","title":"什么是泛型？","index":"13","children":[{"id":"泛型函数","title":"泛型函数","index":"13.1"},{"id":"泛型类型","title":"泛型类型","index":"13.2"},{"id":"泛型约束","title":"泛型约束","index":"13.3"},{"id":"泛型协议","title":"泛型协议","index":"13.4"}]},{"id":"http和https","title":"HTTP和HTTPS","index":"14","children":[{"id":"http的请求过程","title":"HTTP的请求过程","index":"14.1"},{"id":"https加密过程？","title":"HTTPS加密过程？","index":"14.2"}]},{"id":"敏捷开发","title":"敏捷开发","index":"15","children":[{"id":"什么是敏捷开发？","title":"什么是敏捷开发？","index":"15.1"},{"id":"有没有参与过敏捷开发的会议？","title":"有没有参与过敏捷开发的会议？","index":"15.2"}]},{"id":"ios线程","title":"iOS线程","index":"16","children":[{"id":"nsoperation","title":"NSOperation","index":"16.1"},{"id":"gcd","title":"GCD","index":"16.2"},{"id":"nsthread","title":"NSThread","index":"16.3"}]},{"id":"单元测试","title":"单元测试","index":"17","children":[{"id":"xctest","title":"XCTest","index":"17.1"}]},{"id":"英文面试题","title":"英文面试题","index":"18"},{"id":"do-you-have-any-hobbies?你有什么爱好","title":"Do you have any hobbies?你有什么爱好","index":"19"},{"id":"why-did-you-choose-us?你为什么选择我们？","title":"Why did you choose us?你为什么选择我们？","index":"20"},{"id":"what-is-your-greatest-strength?-你最大的优点是什么?","title":"What is your greatest strength? 你最大的优点是什么?","index":"21"},{"id":"简短的自我介绍","title":"简短的自我介绍","index":"22"}],"reading_time":"4408 words in 29 min"}