{"title":"Runloop","date":"2021-11-16T16:00:00.000Z","date_formatted":{"ll":"Nov 17, 2021","L":"11/17/2021","MM-DD":"11-17"},"link":"2021/11/17/Runloop","tags":["iOS"],"updated":"2022-03-03T13:14:39.880Z","content":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>Runloop是和线程紧密相关的一个基础组件，是很多线程有关功能的幕后功臣。尽管在平常使用中几乎不太会直接用到，理解Runloop有利于我们更加深入地理解iOS的多线程模型。</p>\n<h1 id=\"runloop基本概念\">Runloop基本概念<a title=\"#runloop基本概念\" href=\"#runloop基本概念\"></a></h1>\n<p>Runloop是什么？Runloop还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的while循环会导致CPU进入忙等待状态，而Runloop则是一种“闲”等待，这部分可以类比Linux下的epoll。当没有事件时，Runloop会进入休眠状态，有事件发生时，Runloop会去找对应Handler处理事件。Runloop可以让线程在需要做事的时候忙起来，不需要的时候就让线程休眠。</p>\n<p>盗一张苹果官方文档的图，也是几乎每个讲Runloop的文章都会引用的图，大体说明了Runloop的工作模式：<br>\n<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg\" target=\"_blank\"></a><br>\n图中展现了Runloop在线程中的作用：从input source和timer source接受事件，然后在线程中处理事件。</p>\n<h1 id=\"runloop与线程\">Runloop与线程<a title=\"#runloop与线程\" href=\"#runloop与线程\"></a></h1>\n<p>Runloop和线程是绑定在一起。每个线程（包括主线程）都有一个对应的Runloop对象。我们并不能自己创建Runloop对象，但是可以获取到系统提供的Runloop对象。</p>\n<p>主线程Runloop会在应用启动的时候完成启动，其他线程的Runloop默认并不会启动，需要我们手动启动。</p>\n<h1 id=\"input-source和timer-source\">Input Source和Timer Source<a title=\"#input-source和timer-source\" href=\"#input-source和timer-source\"></a></h1>\n<p>这两个都是Runloop事件的来源，其中Input Source又可以分为三类</p>\n<ul>\n<li>Port-Based Sources，系统底层的Port事件，例如CFSocketRef，在应用层基本用不到</li>\n<li>Custom Input Sources，用户手动创建的Source</li>\n<li>Cocoa Perform Selector Sources，Cocoa提供的performSelector系列方法，也是一种事件源</li>\n</ul>\n<p>Timer Source顾名思义就是指定时器事件了。</p>\n<h1 id=\"runloop-observer\">Runloop Observer<a title=\"#runloop-observer\" href=\"#runloop-observer\"></a></h1>\n<p>Runloop通过监控Source来决定有没有任务要做，除此之外，我们还可以用Runloop Observer来监控Runloop本身的状态。Runloop Observer可以监控下面的runloop事件：</p>\n<ul>\n<li>The entrance to the run loop</li>\n<li>When the run loop is about to process a timer</li>\n<li>When the run loop is about to process an input source</li>\n<li>When the run loop is about to go to sleep</li>\n<li>When the run loop has woken up，but before is has processed the event that woke is up</li>\n<li>The exit from the run loop</li>\n</ul>\n<h1 id=\"runloop-mode\">Runloop Mode<a title=\"#runloop-mode\" href=\"#runloop-mode\"></a></h1>\n<p>在监视与被监视中，Runloop要处理的事情还挺复杂的。为了让Runloop能专心处理自己关心的那部分事情，引入了Runloop Mode概念。<br>\n<a href=\"http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png\" target=\"_blank\"></a><br>\n如图所示，Runloop Mode实际上是Source，Timer和Observer的集合，不同的Mode把不同组的Source，Timer和Observer隔绝开来。Runloop在某个时刻只能跑在一个Mode下，处理这一个Mode当中的Source，Timer和Observer。</p>\n<p>苹果文档中提到的Mode有五个，分别是：</p>\n<ul>\n<li>NSDefaultRunLoopMode</li>\n<li>NSConnectionReplyMode</li>\n<li>NSModalPanelRunLoopMode</li>\n<li>NSEventTrackingRunLoopMode</li>\n<li>NSRunLoopCommonModes<br>\niOS中公开暴露出来的只有NSDefaultRunLoopMode和NSRunLoopCommonModes。<br>\nNSRunLoopCommonModes实际上是一个Mode的集合，默认包括NSDefaultRunLoopMode和NSEventTrackingRunLoopMode。</li>\n</ul>\n<h1 id=\"与runloop相关的坑\">与Runloop相关的坑<a title=\"#与runloop相关的坑\" href=\"#与runloop相关的坑\"></a></h1>\n<p>日常开发中，与runloop接触得最近可能就是通过NSTimer了。一个Timer一次只能加入到一个Runloop中。我们日常使用的时候，通常就是加入到当前的runloop的default mode中，而ScrollView在用户滑动时，主线程Runloop会转到UITrackingRunLoopMode。而这个时候，Timer就不会运行。</p>\n<p>有如下两种解决方案：</p>\n<ul>\n<li>第一种：设置RunLoop Mode，例如NSTimer，我们指定它运行于NSRunLoopCommonModes，这是一个Mode的集合。注册这个Mode下后，无论当前runloop运行哪个mode，事件都能得到执行。</li>\n<li>第二种：另一种解决Timer的方法是，我们在另外一个线程执行和处理Timer事件，然后在主线程更新UI。</li>\n</ul>\n<p>在AFNetworking3.0中，就有相关的代码，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)startActivationDelayTimer &#123;</span><br><span class=\"line\">  self.activationDelayTimer = [NSTimer timerWithTimeInterval:self.activationDelay target:self selector:@selector(activationDelayTimerFired) userInfo:nil repeats:NO];</span><br><span class=\"line\">  [[NSRunLoop mainRunLoop] addTimer:self.activationDelayTimer forMode:NSRunLoopCommonModes];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是添加了一个计时器，由于指定了NSRunLoopCommonModes，所以不管RunLoop处于什么状态，都执行这个计时器任务。</p>\n","prev":{"title":"React-Native中常用的命令","link":"2021/12/15/React-Native常用命令"},"next":{"title":"MRC下retain所影响retainCount的变化","link":"2021/11/15/MRC下retain所影响retainCount的变化"},"plink":"http://hongweichen.github.io/2021/11/17/Runloop/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"runloop基本概念","title":"Runloop基本概念","index":"2"},{"id":"runloop与线程","title":"Runloop与线程","index":"3"},{"id":"input-source和timer-source","title":"Input Source和Timer Source","index":"4"},{"id":"runloop-observer","title":"Runloop Observer","index":"5"},{"id":"runloop-mode","title":"Runloop Mode","index":"6"},{"id":"与runloop相关的坑","title":"与Runloop相关的坑","index":"7"}],"reading_time":"1022 words in 7 min"}