{"title":"Objective-C NSString","date":"2021-11-08T16:00:00.000Z","date_formatted":{"ll":"Nov 9, 2021","L":"11/09/2021","MM-DD":"11-09"},"link":"2021/11/09/Objective-C NSString","tags":["Objective-C"],"updated":"2022-03-05T07:30:29.214Z","content":"<h1 id=\"前言\">前言<a title=\"#前言\" href=\"#前言\"></a></h1>\n<p>同事因为这几天一直在学习Objective-C相关的基础知识，碰到一些问题探讨了一下，其中NSString的探讨比较有趣，也很久没有复习基础知识了，记录一下。</p>\n<h1 id=\"nsstring的内存\">NSString的内存<a title=\"#nsstring的内存\" href=\"#nsstring的内存\"></a></h1>\n<p>我们都知道，在创建NSString的时候，通过控制台可以观察到NSString不同的创建方式会产生几种不同的类型</p>\n<ul>\n<li>NSCFConstantString，存储于常量区，MRC下无需手动释放，也无法释放。</li>\n<li>NSTaggedPointerString，指针就是字符串的值，所以应该是存储于栈中，但是不会被释放，retainCount是无限大的。</li>\n<li>NSCFString，存储于堆中，MRC下需要手动释放。</li>\n</ul>\n<p>关于NSTaggedPointerString，一开始我也不是很理解这个东西，觉得是存储于常量区，因为他同样不会被释放，但是参考了一些资料之后，认为他是存储于栈中的，我们知道指针是存储于栈中由系统进行管理的，而NSTaggedPointerString本身就是一个指针，而指针本身内存地址本身就存储了String的值，所以它应该是存储于栈中的。</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/201443317\" target=\"_blank\">NSTaggedPointerString参考资料 来自知乎</a></li>\n</ul>\n<p>我们通过<code>NSString *str = @&quot;Hello world&quot;</code>基本都是通过NSCFConstantString来创建的，他会直接存储于常量区，哪怕我在创建一个新的字符串变量<code>NSString *str2 = @&quot;Hello world&quot;</code>他仍然会指向同一个指针地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *str = @&quot;Hello world&quot;;</span><br><span class=\"line\">NSString *str2 = @&quot;Hello world&quot;;</span><br><span class=\"line\">NSLog(@&quot;%p&quot;, str);</span><br><span class=\"line\">NSLog(@&quot;%p&quot;, str2);</span><br><span class=\"line\"></span><br><span class=\"line\">2021-11-15 12:08:01.595187+0800 Test[69527:1679878] 0x10e0620b8</span><br><span class=\"line\">2021-11-15 12:08:12.793815+0800 Test[69527:1679878] 0x10e0620b8</span><br></pre></td></tr></table></figure>\n<h1 id=\"nscfstring\">NSCFString<a title=\"#nscfstring\" href=\"#nscfstring\"></a></h1>\n<p>通过stringWithFormat方法创建的NSString类型基本都为NSCFString(字符串较短的情况下，则为NSTaggedPointerString)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *str = [NSString stringWithFormat:@&quot;%@&quot;, @&quot;Hello world&quot;];</span><br><span class=\"line\">NSLog(@&quot;%ld&quot;, str.retainCount);</span><br><span class=\"line\">// 结果是1</span><br></pre></td></tr></table></figure>\n<p>当str出了这个作用域后，str随后就会被release释放，若在MRC下要保证str在出了作用域不被释放，可以调用[str retain]方法，将retainCount+1，创建一个weak属性，来引用该字符串，在不需要使用在字符串时，将weak对象调用release。</p>\n<p>而在ARC环境下，则需要用copy或者strong修饰符来引用该字符串，否则仍然会得到(null)的结果。</p>\n","prev":{"title":"React-Redux 原理","link":"2021/11/10/React-Redux 原理"},"next":{"title":"Objective-C NSObject","link":"2021/11/08/Objective-C NSObject"},"plink":"http://hongweichen.github.io/2021/11/09/Objective-C NSString/","toc":[{"id":"前言","title":"前言","index":"1"},{"id":"nsstring的内存","title":"NSString的内存","index":"2"},{"id":"nscfstring","title":"NSCFString","index":"3"}],"reading_time":"564 words in 4 min"}