{"title":"MRC下retain所影响retainCount的变化","date":"2021-11-14T16:00:00.000Z","date_formatted":{"ll":"Nov 15, 2021","L":"11/15/2021","MM-DD":"11-15"},"author":"HongWeiChen","link":"2021/11/15/2021-11-15-MRC下retain所影响retainCount的变化","tags":["原创"],"updated":"2021-12-23T03:52:19.000Z","content":"<h1 id=\"mrc下的一些测试\">MRC下的一些测试<a title=\"#mrc下的一些测试\" href=\"#mrc下的一些测试\"></a></h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo *f = [[Foo alloc] init];</span><br><span class=\"line\">NSLog(@&quot;%d&quot;, [f retainCount]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果是1</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) Foo *retainFoo;</span><br><span class=\"line\"></span><br><span class=\"line\">self.retainFoo = [[Foo alloc] init];</span><br><span class=\"line\">NSLog(@&quot;%d&quot;, [self.retainFoo retainCount]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果是2</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) Foo *strongFoo;</span><br><span class=\"line\"></span><br><span class=\"line\">self.strongFoo = [[Foo alloc] init];</span><br><span class=\"line\">NSLog(@&quot;%d&quot;, [self.strongFoo retainCount]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果是2</p>\n</blockquote>\n<p>由此可见，在MRC模式下，strong与retain并没有什么太大区别，而在ARC模式下，retain和strong使用起来也不会存在什么问题。</p>\n<h1 id=\"换一种方式进行测试\">换一种方式进行测试<a title=\"#换一种方式进行测试\" href=\"#换一种方式进行测试\"></a></h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) Foo *retainFoo;</span><br><span class=\"line\"></span><br><span class=\"line\">_retainFoo = [[Foo alloc] init];</span><br><span class=\"line\">NSLog(@&quot;%d&quot;, [self.retainFoo retainCount]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果是1</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) Foo *strongFoo;</span><br><span class=\"line\"></span><br><span class=\"line\">_strongFoo = [[Foo alloc] init];</span><br><span class=\"line\">NSLog(@&quot;%d&quot;, [self.strongFoo retainCount]);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果是1</p>\n</blockquote>\n<h1 id=\"为什么retaincount会是2？换成下划线又会是1？\">为什么retainCount会是2？换成下划线又会是1？<a title=\"#为什么retaincount会是2？换成下划线又会是1？\" href=\"#为什么retaincount会是2？换成下划线又会是1？\"></a></h1>\n<p>self本身会进行一次retain引用计数自增，而[[Foo alloc] init]这行代码也会产生一次引用计数自增的动作，所以retainCount会是2，而当我们使用下划线来赋值时，不会调用内存修饰符retain的行为。</p>\n<h1 id=\"内部是如何处理的？\">内部是如何处理的？<a title=\"#内部是如何处理的？\" href=\"#内部是如何处理的？\"></a></h1>\n<p>retain的内部是将旧值release，重新赋值，并且retain，相当于是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[foo release];</span><br><span class=\"line\">foo = newObj;</span><br><span class=\"line\">[foo retain];</span><br></pre></td></tr></table></figure>\n<p>执行了这样的一个行为，而newObj本身在传递进来的时候，retainCount已经是1了，所以在retain的时候就变成了2</p>\n","prev":{"title":"2016-05-26-CocoaPods连接不上服务器","link":"2021/11/15/2016-05-26-CocoaPods连接不上服务器"},"next":{"title":"React-Native与原生通信","link":"2021/11/15/2021-11-15-React-Native与原生通信"},"plink":"http://hongweichen.github.io/2021/11/15/2021-11-15-MRC下retain所影响retainCount的变化/","toc":[{"id":"mrc下的一些测试","title":"MRC下的一些测试","index":"1"},{"id":"换一种方式进行测试","title":"换一种方式进行测试","index":"2"},{"id":"为什么retaincount会是2？换成下划线又会是1？","title":"为什么retainCount会是2？换成下划线又会是1？","index":"3"},{"id":"内部是如何处理的？","title":"内部是如何处理的？","index":"4"}],"reading_time":"337 words in 2 min"}