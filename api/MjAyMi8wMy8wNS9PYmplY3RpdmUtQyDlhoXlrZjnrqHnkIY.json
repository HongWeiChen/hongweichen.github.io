{"title":"Objective-C 内存管理","date":"2022-03-04T16:00:00.000Z","date_formatted":{"ll":"Mar 5, 2022","L":"03/05/2022","MM-DD":"03-05"},"link":"2022/03/05/Objective-C 内存管理","tags":["Objective-C"],"updated":"2022-03-09T08:40:28.749Z","content":"<h1 id=\"objective-c中的内存分配\">Objective-C中的内存分配<a title=\"#objective-c中的内存分配\" href=\"#objective-c中的内存分配\"></a></h1>\n<p>在Objective-C中，对象通常是使用alloc方法在堆上创建的。<code>[NSObject alloc]</code>方法会在堆上分配一块内存，按照<code>NSObject</code>的内部结构填充这块儿的内存区域。</p>\n<p>一旦对象创建完成，就不可能再移动它了。因为很可能有很多指针都指向这个对象，这些指针并没有被追踪。因此没有办法在移动对象的位置之后更新全部的指针。</p>\n<h1 id=\"mrc与arc\">MRC与ARC<a title=\"#mrc与arc\" href=\"#mrc与arc\"></a></h1>\n<p>Objective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和ARC（AutomaticReference Counting），分别提供对内存的手动管理和自动管理，来满足不同的需求。现在苹果推荐使用ARC来进行内存管理。</p>\n<h1 id=\"mrc\">MRC<a title=\"#mrc\" href=\"#mrc\"></a></h1>\n<p>对象操作的四个类别</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">对象操作</th>\n<th style=\"text-align:center\">OC中对应的方法</th>\n<th style=\"text-align:center\">对应的retainCount变化</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">生成并持有对象</td>\n<td style=\"text-align:center\">alloc/new/copy/mutableCopy</td>\n<td style=\"text-align:center\">+1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">持有对象</td>\n<td style=\"text-align:center\">retain</td>\n<td style=\"text-align:center\">+1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">释放对象</td>\n<td style=\"text-align:center\">release</td>\n<td style=\"text-align:center\">-1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">废弃对象</td>\n<td style=\"text-align:center\">dealloc</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n</tbody>\n</table></div></div><p><strong>注意：</strong></p>\n<ul>\n<li><s>这些对象操作的方法其实并不包括在OC中，而是包含在Cocoa框架下的Foundation框架中。</s><a href=\"https://developer.apple.com/library/archive/releasenotes/General/iOS70APIDiffs/index.html\" target=\"_blank\">从iOS7开始</a>，这些方法被移动到了Runtime当中，可以在<a href=\"https://opensource.apple.com/source/objc4/objc4-680/runtime/NSObject.h\" target=\"_blank\">objc4-680 NSObject.h</a>找到。</li>\n<li>对象<code>retainCount</code>属性并没有实际上的参考价值，参考苹果官方文档<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html\" target=\"_blank\">《Practical Memory Management》</a></li>\n</ul>\n<h1 id=\"四个法则\">四个法则<a title=\"#四个法则\" href=\"#四个法则\"></a></h1>\n<ul>\n<li>自己生成的对象，自己持有</li>\n<li>非自己生成的对象，自己也能持有</li>\n<li>不再需要自己持有的对象的时候，释放。</li>\n<li>非自己持有的对象无需释放。</li>\n</ul>\n<p>如下是四个黄金法则对应的代码示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 自己生成的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\"> id obj0 = [[NSObject alloc] init];</span><br><span class=\"line\"> id obj1 = [NSObject new];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 持有非自己生成的对象</span><br><span class=\"line\"> */</span><br><span class=\"line\"> id obj = [NSArray array]; // 非自己生成的对象，切该对象存在，但自己不持有。</span><br><span class=\"line\"> [obj retain]; // 自己持有对象</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * 不再需要自己持有的对象的时候，释放</span><br><span class=\"line\"> */</span><br><span class=\"line\"> id obj = [[NSObject alloc] init]; // 此时持有对象</span><br><span class=\"line\"> [obj release]; // 释放对象</span><br><span class=\"line\"> /*</span><br><span class=\"line\">  * 指向对象的指针仍就被保存在obj这个变量中</span><br><span class=\"line\">  * 但对象已释放，不可访问</span><br><span class=\"line\">  */</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  非自己持有的对象无法释放</span><br><span class=\"line\"> */</span><br><span class=\"line\"> id obj = [NSArray array];  // 非自己持有的对象，且对象存在，但自己不持有</span><br><span class=\"line\"> [obj release]; // 非ARC下，调用该方法会导致编译器报issues。此操作行为是未定义的，可能会导致运行时crash或者其他未知行为</span><br></pre></td></tr></table></figure>\n<p>其中<code>非自己生成的对象，且该对象存在，但自己不持有</code>这个特性是使用<code>autorelease</code>来实现的，示例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)getAObjNotRetain &#123;</span><br><span class=\"line\">  id obj = [[NSObject alloc] init]; // 自己持有对象</span><br><span class=\"line\">  [obj autorelease]; // 取得的对象存在，但自己不持有该对象</span><br><span class=\"line\">  return obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>autorelease</code>使得对象在超出生命周期后能正确被释放（通过调用dealloc方法）。在调用<code>release</code>后，对象会被立即释放，而调用<code>autorelease</code>后，对象不会立即被释放，而是注册到<code>autoreleasepool</code>中，经过一段时间后<code>pool</code>结束，此时调用release方法，对象被释放。</p>\n<p>在MRC的内存管理模式下，与对变量的管理相关的方式有：retain、release和autorelease。retain和release方法操作的是引用技术，当引用技术为零时，便自动释放内存。并且可以用<code>NSAutoreleasePool</code>对象，对加入自动释放池（autorelease调用）的变量进行管理，当drain时内存回收。</p>\n<h1 id=\"arc\">ARC<a title=\"#arc\" href=\"#arc\"></a></h1>\n<p>ARC是苹果引入的一种自动内存管理机制，会根据引用技术自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在Runtime做一些优化。</p>\n<h1 id=\"变量标识符\">变量标识符<a title=\"#变量标识符\" href=\"#变量标识符\"></a></h1>\n<p>在ARC中与内存管理有关的变量标识符，有下面几种：</p>\n<ul>\n<li><code>___strong</code></li>\n<li><code>__weak</code></li>\n<li><code>__unsafe_unretained</code></li>\n<li><code>__autoreleasing</code><br>\n<code>__strong</code>是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。<br>\n<code>__weak</code>声明这个引用不会保持被引用对象的存活，如果对象有强引用了，弱引用会被置为nil<br>\n<code>__unsafe_unretained</code>声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会置为nil。如果它引用的对象被回收掉了，该指针就变成野指针。<br>\n<code>__autoreleasing</code>用于表示使用引用传值的参数（id *），在函数返回时会被自动释放掉。<br>\n变量标识符的用法如下</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber * __strong num = [[NSNumber alloc] init];</span><br></pre></td></tr></table></figure>\n<p>注意<code>__strong</code>的位置应该放到<code>*</code>和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。</p>\n<h1 id=\"属性标识符\">属性标识符<a title=\"#属性标识符\" href=\"#属性标识符\"></a></h1>\n<p>类中的属性也可以加上标识符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(assign/retain/strong/weak/unsafe_unretained/copy) NSNumber *num;</span><br></pre></td></tr></table></figure>\n<p><code>assign</code>表明setter仅仅是一个简单的赋值操作，通常用于基本的数据类型，例如<code>CGFloat</code>和<code>NSInteger</code>。<br>\n<code>strong</code>表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行<code>retain</code>，旧值进行<code>release</code>，然后进行赋值。<br>\n<code>weak</code>表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行<code>retain</code>，旧值也不会进行<code>release</code>，而是进行类似<code>assign</code>的操作。不过当属性指向的对象被销毁时，该属性也会置为nil。<br>\n<code>unsafe_unretained</code>的语义和assign相似，不过是用于对象类型的，表示一个非拥有（unretained）的，同时也不会在对象被销毁时置为nil的（unsafe）关系。<br>\n<code>copy</code>类似于strong，不过在赋值时进行<code>copy</code>操作而不是<code>retain</code>操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。</p>\n<h1 id=\"错误使用属性标识的后果\">错误使用属性标识的后果<a title=\"#错误使用属性标识的后果\" href=\"#错误使用属性标识的后果\"></a></h1>\n<p>如果我们给一个原始类设置<code>strong\\weak\\copy</code>，编译器会直接报错：</p>\n<blockquote>\n<p>Property with ‘retain(or strong)’ attribute must be of object type</p>\n</blockquote>\n<p>设置为<code>unsafe_unretained</code>倒是可以通过编译，只是用起来跟<code>assign</code>也没有什么去别。<br>\n反过来，我们给一个NSObject属性设置为assign，编译器会报警：<br>\n<code>Assigning retained object to unsafe property; object will be released after assignment</code><br>\n正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成<code>unsafe_unretained</code>是一样的效果（设置成<code>weak</code>不会崩溃）。</p>\n<h1 id=\"unsafe_unretained的用处\"><code>unsafe_unretained</code>的用处<a title=\"#unsafe_unretained的用处\" href=\"#unsafe_unretained的用处\"></a></h1>\n<p><code>unsafe_unretained</code>差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点：</p>\n<ol>\n<li>兼容性考虑。iOS4以前之前还没有引入<code>weak</code>，这种情况想表达弱引用的语义只能使用<code>unsafe_unretained</code>。这种情况现在很少见了。</li>\n<li>性能考虑。使用<code>weak</code>对性能有一些影响，因此对性能要求高的地方可以考虑使用<code>unsafe_unretained</code>替换<code>weak</code>。一个例子是[YYModel的实现]，为了追求更高的性能，其中大量使用<code>unsafe_unretained</code>作为变量的标识符。</li>\n</ol>\n<h1 id=\"引用循环\">引用循环<a title=\"#引用循环\" href=\"#引用循环\"></a></h1>\n<p>当两个对象互相持有对方的强引用，并且这两个对象的引用技术都不是0的时候，便造成了引用循环。</p>\n<p>要想破除引用循环，可以从以下几点入手：</p>\n<ul>\n<li>注意变量作用域，使用<code>autorelease</code>让编译器来处理引用</li>\n<li>使用弱引用(weak)</li>\n<li>当实例变量完成工作后，将其置为nil</li>\n</ul>\n<h1 id=\"autorelease-pool\">Autorelease pool<a title=\"#autorelease-pool\" href=\"#autorelease-pool\"></a></h1>\n<p>Autorelease Pool提供了一种可以允许你向一个对象延迟发送<code>release</code>消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool的作用就显现出来了。</p>\n<p>所谓的延迟发送<code>release</code>消息指的是，当我们把一个对象标记为<code>autorelease</code>时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString* str = [[[NSString alloc] initWithString:@&quot;hello&quot;] autorelease]</span><br></pre></td></tr></table></figure>\n<p>这个对象的retainCount+1，但是不会发生release。当这段语句所处的autoreleasepool进行drain操作时，所有标记了<code>autorelease</code>的对象的retainCount-1。即<code>release</code>消息发送被延迟到pool释放的时候了。</p>\n<p>在ARC环境下，苹果引入了<code>@autoreleasepool</code>语法，不再需要手动调用<code>autorelease</code>和<code>drain</code>等方法。</p>\n<h1 id=\"autorelease-pool的用处\">Autorelease Pool的用处<a title=\"#autorelease-pool的用处\" href=\"#autorelease-pool的用处\"></a></h1>\n<p>在ARC下，我们并不需要手动调用autorelease有关的方法，甚至可以完全不知道autorelease的存在，就可以正确管理好内存。因为Cocoa Touch的Runloop中，每个runloop circle中系统都加入了Autorelease Pool的创建和释放。</p>\n<p>当我们需要创建和销毁大量对象时，使用手动创建的autoreleasepool可以有效的避免内存峰值的出现。因为如果不需要手动创建的话，外层系统创建的pool会在整个runloop circle结束之后drain，手动创建的话，会在block结束之后就进行drain操作。详情请参考<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI\" target=\"_blank\">苹果官方文档</a>。一个普遍被使用的例子如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 0; i &lt; 100000000; i++) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    NSString* string = @&quot;ab c&quot;;</span><br><span class=\"line\">    NSArray* array = [string componentsSeparatedByString:string];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果不实用autoreleasepool，需要在循环结束之后释放100000000个字符，如果使用的话，则会在每次循环结束的时候都进行release操作。</p>\n<h1 id=\"autorelease-pool进行drain时机\">Autorelease Pool进行Drain时机<a title=\"#autorelease-pool进行drain时机\" href=\"#autorelease-pool进行drain时机\"></a></h1>\n<p>如上main所说，系统在runloop中创建的autoreleasepool会在runloop一个event结束时进行释放操作。我们手动创建的autorelease会在block执行完成之后进行drain操作。需要注意的是：</p>\n<ul>\n<li>当block以异常（exception）结束时，pool不会被drain</li>\n<li>Pool的drain操作会把所有标记为autorelease的对象的引用技术减一，但是并不意味着这个对象一定会被释放掉，我们可以在autorelease pool中手动retain对象，以延长它的生命周期，（在MRC中）。</li>\n</ul>\n<h1 id=\"main.m中autorelease-pool的解释\">main.m中Autorelease Pool的解释<a title=\"#main.m中autorelease-pool的解释\" href=\"#main.m中autorelease-pool的解释\"></a></h1>\n<p>大家都知道iOS程序的main.m文件中有类似这样的语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">  @autoreleasepool &#123;</span><br><span class=\"line\">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在面试中问到有关autorelease pool有关的知识也多半会问一下，这里的pool有什么作用，能不能去掉之类。在这里我们分析以下。</p>\n<p>根据苹果官方文档，UIApplicationMain是函数是整个app的入口，用来创建application对象（单例）和application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下Home键时，app只是被切换到了后台状态。</p>\n<p>同时参考苹果关于Lifecycle的<a href=\"https://developer.apple.com/documentation/uikit\" target=\"_blank\">官方文档</a>，UIApplication自己会创建一个main run loop，我们大致可以得到下面的结论：</p>\n<ol>\n<li>main.m中的UIApplicationMain永远不会返回，只有在系统kill掉整个app时，系统会把应用占用的内存全部释放出来。</li>\n<li>因为（1），UIApplicationMain永远不会返回，这里的autorelease pool也就永远不会进入到释放那个阶段。</li>\n<li>在（2）的基础上，假设有些变量真的进入main.m里面的pool（没有被更内层的pool捕获），那么这些变量实际上就是被泄漏的。这个autorelease pool等于是把这种泄漏情况给隐藏起来了。</li>\n<li>UIApplication自己会创建main run loop，在Cocoa的runloop中实际上也是自动包含autoreleasepool的，因为main.m当中的pool可以认为是<strong>没有</strong>必要的。<br>\n在基于AppKit框架的Mac OS开发中，main.m当中就是不存在autorelease pool的，也进一步验证了我们得到的结论。不过因为我们看不到更底层的代码，加上苹果的文档中不建议修改main.m，所以我们也没有理由直接把它删掉（亲测，删掉后不影响App运行，用Instruments也看不到泄漏）。</li>\n</ol>\n<h1 id=\"autorelease-pool与函数返回值\">Autorelease Pool与函数返回值<a title=\"#autorelease-pool与函数返回值\" href=\"#autorelease-pool与函数返回值\"></a></h1>\n<p>如果一个函数的返回值是指向同一个对象的指针，那么这个对象肯定不能在函数返回之前进行release，这样调用者在调用这个函数时得到的就是野指针了，在函数返回之后也不能立刻就release，因为我们不知道调用者是不是retain了这个对象，如果我们直接release了，可能导致后面在使用这个对象时它已经成为nil了。</p>\n<p>为了解决这个纠结的问题，Objective-C中对对象指针的返回值进行了区分，一种叫做<em>retained return value</em>，另一种叫做<em>unretained return value</em>。前者表示调用者拥有这个返回值，后者表示调用者不拥有这个返回值，按照“谁拥有谁释放”的原则，对于前者调用者是要负责释放的，对于后者就不需要了。</p>\n<p>按照苹果的命名convention，以<code>alloc</code>，<code>copy</code>，<code>init</code>，<code>mutableCopy</code>和<code>new</code>这些方法打头的方法，返回的都是retained return value，例如<code>[[NSString alloc] initWithFormat:]</code>，而其他的则是unretained return value，例如<code>[NSString stringWithFormat:]</code>。我们在编写代码时也应该遵守这个convention。</p>\n<p>我们分别在MRC和ARC情况下，分析一下这两种返回值类型的去别。</p>\n<h5 id=\"mrc-1\">MRC<a title=\"#mrc-1\" href=\"#mrc-1\"></a></h5>\n<p>在MRC中我们需要关注这两种函数返回类型的区别，否则可能会导致内存泄漏。</p>\n<p><em>对于retained return value，需要负责释放</em></p>\n<p>假设我们有一个property定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (nonatomic, retain) NSObject *property;</span><br></pre></td></tr></table></figure>\n<p>在对其赋值的时候，我们应该使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.property = [[[NSObject alloc] init] autorelease];</span><br></pre></td></tr></table></figure>\n<p>然后在进入dealloc方法中加入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_property release];</span><br><span class=\"line\">_property = nil;</span><br></pre></td></tr></table></figure>\n<p>这样内存的情况大体是这样的：</p>\n<ol>\n<li>init把retain count增加到1</li>\n<li>赋值给self.property，把retain count增加到2</li>\n<li>当runloop circle结束时，autorelease pool执行drain，把retain count减为1</li>\n<li>当整个对象执行dealloc时，release把retain count减为0，对象被释放</li>\n</ol>\n<p>可以看到没有内存泄漏发生。</p>\n<p>如果我们只是使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.property = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>这一条语句会导致retain count增加到2，而我们少执行一次release，就会导致retain count不能被减为0。<br>\n另外，我们也可以使用临时变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSObject* a = [[NSObject alloc] init];</span><br><span class=\"line\">self.property = a;</span><br><span class=\"line\">[a release];</span><br></pre></td></tr></table></figure>\n<p>这种情况，因为对a执行一次release，所有不会出现上面那种retain count不能减为0的情况。</p>\n<p><strong>注意</strong>：现在大家基本都是ARC写的比较多，会忽略这一点，但是根据上面的内容，我们看到在MRC中直接对self.property赋值和先赋给临时变量，再赋值给self.property，确实是有区别的！我在面试中就被问到这一点了。</p>\n<p>我们在编写自己的代码时，也应该遵守上面的原则，同样是使用autorelease：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意函数名的区别</span><br><span class=\"line\">+ (MyCustomClass *)myCustomClass &#123;</span><br><span class=\"line\">  return [[[MyCustomClass alloc] init] autorelease]; // 需要autorelease</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (MyCustomClass *)initWithName:(NSString *)name &#123;</span><br><span class=\"line\">  return [[MyCustomClass alloc] init]; // 不需要autorelease</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>对于unretained return value，不需要负责释放</em></p>\n<p>当我们调用非alloc，init系的方法来初始化对象时（通常是工厂方法），我们不需要负责的释放，可以当成普通的临时变量来时用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString* name = [NSString stringWithFormat:@&quot;%@ %@&quot;, firstName, lastName];</span><br><span class=\"line\">self.name = name;</span><br><span class=\"line\">// 不需要执行release</span><br></pre></td></tr></table></figure>\n<h5 id=\"arc-1\">ARC<a title=\"#arc-1\" href=\"#arc-1\"></a></h5>\n<p>在ARC中我们完全不需要考虑这两种返回值类型的区别，ARC会自动加入必要的代码，因此我们可以放心大胆地写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.property = [[NSObject alloc] init];</span><br><span class=\"line\">self.name = [NSString stringWithFormat:@&quot;%@ %@&quot;, firstName, lastName];</span><br></pre></td></tr></table></figure>\n<p>以及在自己写的函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (MyCustomClass *)myCustomClass &#123;</span><br><span class=\"line\">  return [[MyCustomClass alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些写法都是OK的，也不会出现内存问题。<br>\n为了进一步理解ARC是如何做到这一点的，我们可以参考Clang的<a href=\"https://clang.llvm.org/docs/AutomaticReferenceCounting.html#unretained-return-values\" target=\"_blank\">文档</a>。<br>\n对于retained return value，Clang是这样做的：</p>\n<blockquote>\n<p>When returning from such a function or method, ARC retains the value at the point of evaluation of the return statement, before leaving all local scopes.</p>\n</blockquote>\n<blockquote>\n<p>When receiving a return result from such a function or method, ARC releases the value at the end of the full-expression it is contained within, subject to the usual optimizations for local values.</p>\n</blockquote>\n<p>可以看到基本上ARC就是帮我们在代码块结束的时候进行了release：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSObject* a = [[NSObject alloc] init];</span><br><span class=\"line\">self.property = a;</span><br><span class=\"line\">// [a release]; 我们不需要写这一句，因为ARC会帮我们把这一句加上</span><br></pre></td></tr></table></figure>\n<p>对于unretained return value：</p>\n<blockquote>\n<p>When returning from such a function or method, ARC retains the value at the point of evaluation of the return statement, then leaves all local scopes, and then balances out the retain while ensuring that the value lives across the call boundary. In the worst case, this may involve an autorelease, but callers must not assume that the value is actually in the autorelease pool.</p>\n</blockquote>\n<blockquote>\n<p>ARC performs no extra mandatory work on the caller side, although it may elect to do something to shorten the lifetime of the returned value.</p>\n</blockquote>\n<p>这个和我们之前在MRC中做的不是完全一样。ARC会把对象的生命周期延长，确保调用者能拿到并且使用这个返回值，但是并不一定会使用autorelease，文档写的是worst case的情况下才可能会使用，因此调用者不能假设返回值真的就在autoreleasepool中。从性能的角度，这种做法也是可以理解的。如果我们能够知道一个对象的生命周期最长应该有多长，也就没有必要使用autorelease了，直接使用release就可以。如果很多对象都使用autorelease的话，也会导致整个pool在drain的时候性能下降。</p>\n<h5 id=\"weak和autorelease\">weak和autorelease<a title=\"#weak和autorelease\" href=\"#weak和autorelease\"></a></h5>\n<p>众所周知，weak不会持有对象，当给一个weak赋以一个自己生成的对象（即上面提到的retained return value）后，对象会立即被释放。</p>\n<p>一个很常见的warning就是Assigning retained object to weak variable, object will be released after assignment.</p>\n<p>但是我们前面也提到了，可以持有非自己生成的对象，这通过autorelease实现。</p>\n<p>那么如果一个weak被赋以一个非自己生成的对象（即上面提到的unretained return value）呢？代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber __weak *number = [NSNumber numberWithInt:100];</span><br><span class=\"line\">NSLog(@&quot;number = %@&quot;, number);</span><br></pre></td></tr></table></figure>\n<p>这种情况下是可以正确打印的。<br>\n<a href=\"https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak\" target=\"_blank\">clang的文档</a>是这么说的：这种情况下，weak并不会立即释放，而是会通过<code>objc_loadWeak</code>这个方法注册到AutoreleasePool中，以延长生命周期。</p>\n<h5 id=\"arc下是否还有必要在dealloc中把属性置为nil\">ARC下是否还有必要在dealloc中把属性置为nil<a title=\"#arc下是否还有必要在dealloc中把属性置为nil\" href=\"#arc下是否还有必要在dealloc中把属性置为nil\"></a></h5>\n<p>为了解决这个问题，首先让我们理清楚属性是个什么存在。属性（property）实际上就是一种语法糖，每个属性背后都有实例变量（var），编译器会帮我们自动生成有关的setter和getter，对于下面的property：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Counter: NSObject</span><br><span class=\"line\">@property (nonatomic, retain) NSNumber *count;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>生成的getter和setter类似下面这样</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSNumber *)count &#123;</span><br><span class=\"line\">  return _count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setCount:(NSNumber *)newCount &#123;</span><br><span class=\"line\">  [newCount retain];</span><br><span class=\"line\">  [_count release];</span><br><span class=\"line\">  // Make the new assignment</span><br><span class=\"line\">  _count = newCount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Property这部分对于MRC和ARC都是适用的。<br>\n有了这部分基础，我们再来理解一下把属性置为nil这个步骤。首先要明确一点，在MRC下，我们并不是真的把属性置为nil，而是把Ivar置为nil。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[_property release];</span><br><span class=\"line\">_property = nil;</span><br></pre></td></tr></table></figure>\n<p>如果用self.property的话还会调用setter，里面可能存在某些不应该在dealloc时运行的代码。<br>\n对于ARC来说，系统会自动在dealloc的时候把所有Ivar都执行release，因此我们也就没有必要在dealloc中写有关release的代码了。</p>\n<h5 id=\"在arc下把变量置为nil有什么效果？什么情况下需要把变量置为nil？\">在ARC下把变量置为nil有什么效果？什么情况下需要把变量置为nil？<a title=\"#在arc下把变量置为nil有什么效果？什么情况下需要把变量置为nil？\" href=\"#在arc下把变量置为nil有什么效果？什么情况下需要把变量置为nil？\"></a></h5>\n","next":{"title":"内存管理基础","link":"2022/03/04/内存管理基础"},"plink":"http://hongweichen.github.io/2022/03/05/Objective-C 内存管理/","toc":[{"id":"objective-c中的内存分配","title":"Objective-C中的内存分配","index":"1"},{"id":"mrc与arc","title":"MRC与ARC","index":"2"},{"id":"mrc","title":"MRC","index":"3"},{"id":"四个法则","title":"四个法则","index":"4"},{"id":"arc","title":"ARC","index":"5"},{"id":"变量标识符","title":"变量标识符","index":"6"},{"id":"属性标识符","title":"属性标识符","index":"7"},{"id":"错误使用属性标识的后果","title":"错误使用属性标识的后果","index":"8"},{"id":"unsafe_unretained的用处","title":"unsafe_unretained的用处","index":"9"},{"id":"引用循环","title":"引用循环","index":"10"},{"id":"autorelease-pool","title":"Autorelease pool","index":"11"},{"id":"autorelease-pool的用处","title":"Autorelease Pool的用处","index":"12"},{"id":"autorelease-pool进行drain时机","title":"Autorelease Pool进行Drain时机","index":"13"},{"id":"main.m中autorelease-pool的解释","title":"main.m中Autorelease Pool的解释","index":"14"},{"id":"autorelease-pool与函数返回值","title":"Autorelease Pool与函数返回值","index":"15"}],"reading_time":"4893 words in 33 min"}