{"title":"HTTP协议","date":"2021-08-15T16:00:00.000Z","date_formatted":{"ll":"Aug 16, 2021","L":"08/16/2021","MM-DD":"08-16"},"link":"2021/08/16/HTTP协议","tags":["HTTP"],"updated":"2022-03-02T14:34:06.877Z","content":"<h1 id=\"http的特性\">HTTP的特性<a title=\"#http的特性\" href=\"#http的特性\"></a></h1>\n<ul>\n<li>HTTP协议构建于TCP/IP协议之上，是一个应用层协议，默认端口号是80</li>\n<li>HTTP是无连接无状态的</li>\n</ul>\n<h1 id=\"http报文\">HTTP报文<a title=\"#http报文\" href=\"#http报文\"></a></h1>\n<h2 id=\"请求报文\">请求报文<a title=\"#请求报文\" href=\"#请求报文\"></a></h2>\n<p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class=\"line\">&lt;headers&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>\n<p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET、POST、PUT、DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET、POST、PUT、DELETE就对应着这个资源的查、增、改、删4个操作。</p>\n<ol>\n<li>GET请求用于信息获取，而且应该是安全的和幂等的。<br>\n所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像查询数据库一样，不会修改，不会影响资源状态。<br>\n幂等的意味着对同一URL的多个请求应该返回同样的结果。<br>\nGET请求报文示例：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class=\"line\">Gecko/20050225 Firefox/1.0.1</span><br><span class=\"line\">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>POST表示可能修改变服务器上的资源的请求</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST / HTTP/1.1</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class=\"line\">Gecko/20050225 Firefox/1.0.1</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">Content-Length: 40</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">sex=man&amp;name=Professional  </span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>注意：</li>\n</ol>\n<ul>\n<li>GET可提交的数据量受到URL长度的限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定浏览器及服务器对它的限制。</li>\n<li>理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制。</li>\n<li>参考上面的报文示例，可以发现GET和POST数据内容是一模一样的，只是位置不同，一个在URL里，一个在HTTP包的包体了。</li>\n</ul>\n<h1 id=\"post提交数据的方式\">POST提交数据的方式<a title=\"#post提交数据的方式\" href=\"#post提交数据的方式\"></a></h1>\n<p>HTTP协议中规定POST提交的数据必须在body部分中，但是协议中没有规范数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的HTTP请求满足上面的格式就可以。</p>\n<p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如PHP、Python等，以及它们的framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的Content-Type字段来获取请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到POST提交数据方案，包含了Content-Type和消息主体编码方式两部分。下面就正式开始介绍它们：</p>\n<ul>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n<p>这是最常见的POST数据提交方式。浏览器的原生<code>&lt;form&gt;</code>表单，如果不设置enctype属性，那么最终就会以<code>application/x-www-form-urlencoded</code>方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到body当中的内容和GET请求是完全相同的。</p>\n<ul>\n<li><code>multipart/form-data</code></li>\n</ul>\n<p>这又是一个常见的POST数据提交的方式。我们使用表单上传文件时，比如让<code>&lt;form&gt;</code>表单的enctype等于<code>multipart/form-data</code>。直接来看一个请求示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1</span><br><span class=\"line\">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\"></span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">title</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class=\"line\">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class=\"line\">Content-Type: image/png</span><br><span class=\"line\"></span><br><span class=\"line\">PNG ... content of chrome.png ...</span><br><span class=\"line\">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>\n<p>这个例子稍微复杂点。首先生成了一个boundary用于分割不同的字段，为了避免与正文内容重复，boundary很长很复杂。然后<code>Content-Type</code>里指明了数据是以<code>multipart/form-data</code>来编码，本次请求boundary是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以–boundary开始，紧接着是内容描述信息。然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以–boundary–标示结束。关于<code>multipart/form-data</code>的详细定义，请前往<a href=\"https://www.ietf.org/rfc/rfc1867.txt\" target=\"_blank\">RFC1867</a>查看（或者相对友好一点的<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\" target=\"_blank\">MDN文档</a>)</p>\n<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>\n<p>上面提到的这两种POST数据的方式，都是浏览器原生支持的，而且现阶段标注中原生<code>&lt;form&gt;</code>表单也只支持这两种方式（通过<code>&lt;form&gt;</code>元素的enctype属性指定，默认为<code>application/x-www-form-urlencoded</code>。其实enctype还支持text/plain，不过用的非常少。</p>\n<p>随着越来越多的Web站点，尤其是WebApp，全部使用Ajax进行数据交互之后，我们完全可以定义新的数据提交方式，例如<code>application/json</code>，<code>text/xml</code>，乃至<code>application/x-protobuf</code>这种二进制格式，只要服务器可以根据<code>Content-Type</code>和<code>Content-Encoding</code>正确的解析出请求，都是没有问题的。</p>\n<h1 id=\"响应报文\">响应报文<a title=\"#响应报文\" href=\"#响应报文\"></a></h1>\n<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>\n<ul>\n<li>状态行</li>\n<li>响应头（Response Header）</li>\n<li>响应正文</li>\n</ul>\n<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间的空格分隔。</p>\n<p>常见的状态码有如下几种：</p>\n<ul>\n<li><code>200 OK</code>客户端请求成功</li>\n<li><code>301 Moved Permanently</code>请求永久重定向</li>\n<li><code>302 Moved Temporarily</code>请求临时重定向</li>\n<li><code>304 Not Modified</code>文件未修改，可以直接使用缓存的文件</li>\n<li><code>400 Bad Request</code>由于客户端请求语法错误，不能被服务器所理解。</li>\n<li><code>401 Unauthorized</code>请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>\n<li><code>403 Forbidden</code>服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>\n<li><code>404 Not Found</code>请求的资源不存在，例如，输入了错误的URL</li>\n<li><code>500 Internal Server Error</code>服务器发生不可预期的错误，导致无法完成客户端的请求</li>\n<li><code>503 Service Unavailable</code>服务器当前不能够处理客户端的请求，在一段时间后，服务器可能会恢复正常</li>\n</ul>\n<p>下面是一个HTTP响应的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Server:Apache Tomcat/5.0.12</span><br><span class=\"line\">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class=\"line\">Content-Length:112</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;...</span><br></pre></td></tr></table></figure>\n<h1 id=\"条件get\">条件GET<a title=\"#条件get\" href=\"#条件get\"></a></h1>\n<p>HTTP条件GET是HTTP协议为了减少不必要的宽带浪费，提出的一种方案。详见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\" target=\"_blank\">RFC2616</a>。</p>\n<ol>\n<li>HTTP条件GET使用的时机<br>\n客户端之间已经访问过某网站，并打算再次访问该网站</li>\n<li>HTTP条件GET使用的方法<br>\n客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</li>\n</ol>\n<p>下面是一个具体的发送接受报文示例：</p>\n<p>客户端发送请求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1  </span><br><span class=\"line\">Host: www.sina.com.cn:80  </span><br><span class=\"line\">If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  </span><br><span class=\"line\">Connection: Close  </span><br></pre></td></tr></table></figure>\n<p>第一次请求时，服务器端返回请求数据，之后的请求，服务器根据<code>If-Modified-Since</code>字段判断响应文件没有更新，如果没有更新，服务器返回一个<code>304 Not Modified</code>响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 304 Not Modified  </span><br><span class=\"line\">Date: Thu, 04 Feb 2010 12:38:41 GMT  </span><br><span class=\"line\">Content-Type: text/html  </span><br><span class=\"line\">Expires: Thu, 04 Feb 2010 12:39:41 GMT  </span><br><span class=\"line\">Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  </span><br><span class=\"line\">Age: 28  </span><br><span class=\"line\">X-Cache: HIT from sy32-21.sina.com.cn  </span><br><span class=\"line\">Connection: close</span><br></pre></td></tr></table></figure>\n<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>\n<h1 id=\"持久连接\">持久连接<a title=\"#持久连接\" href=\"#持久连接\"></a></h1>\n<p>我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>\n<p>在HTTP 1.0版本中，并没有官方的标准来规定Keep-Alive如何工作，因此实际上它是被附加到HTTP 1.0协议上，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段Connection：Keep-Alive，当服务器收到附带有Connection：Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Keep-Alive。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过Keep-Alive规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已建立的连接。</p>\n<p>在HTTP 1.1版本中，默认情况下所有连接都被保持，如果加入“Connection：Close”才关闭。目前大部分浏览器都使用HTTP 1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。</p>\n<p>由于HTTP 1.0没有官方的Keep-Alive规范，并且也已经基本被淘汰，以下讨论均是针对HTTP 1.1标准中的Keep-Alive展开的。</p>\n<p>注意：</p>\n<ul>\n<li>HTTP Keep-Alive简单说就是保持当前的TCP连接，避免了重新建立连接</li>\n<li>HTTP长连接不可能一直保持，例如<code>Keep-Alive: timeout=5, max=100</code>，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。</li>\n<li>HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP 1.1版本中也是如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖Keep-Alive的保持连接特性，否则会有意想不到的结果。</li>\n<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1.判断传输数据是否达到了Content-Length指示的大小；2.动态生成的文件没有Content-Length，它是分块传输（chunked），这时候就要根据chunked编码来判断，chunked编码的数据在最后一个空chunked块，表明本次传输数据结束，详见<a href=\"https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html\" target=\"_blank\">这里</a>。什么是chunked分块传输呢？下面我们就来介绍一下。</li>\n</ul>\n<h1 id=\"transfer-encoding\">Transfer-Encoding<a title=\"#transfer-encoding\" href=\"#transfer-encoding\"></a></h1>\n<p>Transfer-Encoding是一个用来标示HTTP报文传输格式的头部值。尽管这个取值理论上可以有很多，但是当前HTTP规范里实际上只定义了一种传输值–chunked。</p>\n<p>如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块结束。</p>\n<p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF（回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。</p>\n<p>一个示例响应如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\"></span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\"></span><br><span class=\"line\">25</span><br><span class=\"line\">This is the data in the first chunk</span><br><span class=\"line\"></span><br><span class=\"line\">1A</span><br><span class=\"line\">and this is the second one</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li>chunked和multipart两个名词在意义上有类似的地方，不过在HTTP协议当中这两个概念则不是一个类别的。multipart是一种Content-Type，标示HTTP报文内容的类型，而chunked是一种传输格式，标示报头将以何种方式进行传输</li>\n<li>chunked传输不能事先知道内容的长度，只能靠最后的空chunk块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用空chunked方式下载。</li>\n<li>chunked优势在于，服务端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2不支持Transfer-Encoding：chunked，因为HTTP/2有自己的steaming传输方式（Source：MDN - Transfer - Encoding）。</li>\n</ul>\n<h1 id=\"http-pipelining（http管线化）\">HTTP Pipelining（HTTP管线化）<a title=\"#http-pipelining（http管线化）\" href=\"#http-pipelining（http管线化）\"></a></h1>\n<p>默认情况下HTTP协议中每个传输层连接只能承载一个HTTP请求和响应，浏览器会在收到上一个请求的响应之后，在发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于<code>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</code>。</p>\n<p>HTTP Pipelining（管线化）是将多个HTTP请求整批提交的技术，在传送过程中不需等待服务端的回应。使用HTTP Pipelining技术之后，某个连接上的消息变成了类似这样<code>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</code>。</p>\n<p>注意下面几点：</p>\n<ul>\n<li>管线化机制通过持久连接（persistent connection）完成，仅HTTP/1.1支持此技术(HTTP/1.0不支持)</li>\n<li>只有GET和HEAD请求可以进行管线化，而POST则有所限制。</li>\n<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议</li>\n<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>\n<li>HTTP/1.1要求服务端支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>\n<li>由于上面提到的服务端问题，开启管线化很可能并不会带来很大幅度的性能提升，而且很多服务端和代理程序对管线化的支持并不好，因此现代浏览器和Chrome和Firefox默认并未开启管线化支持。</li>\n</ul>\n<p>更多关于HTTP Pipelining的知识可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x\" target=\"_blank\">这里</a>。</p>\n<h1 id=\"会话跟踪\">会话跟踪<a title=\"#会话跟踪\" href=\"#会话跟踪\"></a></h1>\n<ol>\n<li>什么是会话？<br>\n客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</li>\n<li>什么是会话跟踪？<br>\n会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。</li>\n<li>为什么需要会话跟踪？<br>\n浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是“无协议”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否同一个用户，所以才有会话跟踪技术来实现这种需求。</li>\n</ol>\n<h1 id=\"会话跟踪常用的方法\">会话跟踪常用的方法<a title=\"#会话跟踪常用的方法\" href=\"#会话跟踪常用的方法\"></a></h1>\n<ol>\n<li>URL重写<br>\nURL（统一资源定位符）是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话，把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</li>\n<li>隐藏表单域<br>\n将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示。</li>\n<li>Cookie<br>\nCookie是Web服务器发送客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端，在客户端会进行保存，以便下次使用。<br>\nCookie是可以被客户端禁用的。</li>\n<li>Session<br>\n每一个用户都有一个不同的Session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。<br>\n在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。<br>\nSession的实现依赖于Cookie，如果Cookie被禁用，那么session也会失效。</li>\n</ol>\n<h1 id=\"跨站攻击\">跨站攻击<a title=\"#跨站攻击\" href=\"#跨站攻击\"></a></h1>\n<ul>\n<li>\n<p>CSRF（Cross-site request forgery，跨站请求伪造）<br>\nCSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。<br>\n例如，一论坛网站的发帖是通过GET请求访问，点击发帖之后JS把发帖内容拼接成目标URL并访问：<br>\n<code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容</code><br>\n那么我们只需要在论坛中发一贴，包含一链接<br>\n<code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈</code><br>\n只要有用户点击了链接，那么他们的账户就会在不知情的情况下发布这一帖子。可能这只是个恶作剧，但是既然发帖的请求可以伪造，那么删帖、转账、改密码、发邮件全都可以伪造。<br>\n<strong>如何防范CSRF攻击</strong>？可以注意以下几点：</p>\n<ul>\n<li>关键操作只接受POST请求</li>\n<li>验证码<br>\nCSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效防御了CSRF攻击。<br>\n但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</li>\n<li>监测Referer<br>\n常见的互联网页面与页面之间是存在联系的，比如你在<code>www.baidu.com</code>应该是找不到通往<code>www.google.com</code>的链接的，在比如你在论坛留言，那么不管你留言重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头的Referer中<br>\n通过监测<code>Referer</code>的值，我们就可以判断这个请求的合法还是非法的，但是问题出现在服务器不是任何时候都能接受到<code>Referer</code>的值，所以Referer Check一般用于监控CSRF攻击的发生，而不是用来抵御。</li>\n<li>Token<br>\n目前主流的做法是使用Token抵御CSRF攻击。下面通过分析CSRF攻击来理解为什么Token能够有效<br>\nCSRF攻击要成功的条件在于攻击者能够预测所有参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。<br>\n另一个更通用的做法是保持原有参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。</li>\n</ul>\n<p>Token使用原则</p>\n<ul>\n<li>Token要足够随机，只有这样才算不可预测</li>\n<li>Token是一次性的，即每次请求成功后要更新Token，这样可以增加攻击难度，增加预测难度</li>\n<li>Token要注册保密性，敏感操作使用post，防止Token出现在URL中<br>\n<strong>注意</strong>：过滤用户输入的内容<strong>不能</strong>阻挡csrf，我们需要做的是过滤请求的来源。</li>\n</ul>\n</li>\n<li>\n<p>XSS（Cross Site Scripting，跨站脚本攻击）<br>\nXSS全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有JavaScript的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\n</li>\n</ul>\n<p>运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧，一个关不掉的窗口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">    alert(&quot;你关不掉我~&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以是盗号或者其他未授权的操作。</p>\n<p>XSS是实现CSRF的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过XSS来实现的CSRF称作XSRF。</p>\n<p><strong>如何防御XSS攻击</strong>？</p>\n<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。防御XSS攻击最简单直接的方法，就是过滤用户的输入。<br>\n如果不需要用户输入HTML，可以直接对用户的输入进行HTML escape。下面一小段脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>经过escape之后就成了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。</p>\n<p>当我们需要用户输入HTML的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉script标签是没用的，任何一个合法的HTML标签都可以添加onclick一类的事件属性来执行JavaScript。更好的方法可能是，将用户的输入使用HTML解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建HTML元素树。构建的过程中，所有的标签、属性都只从<strong>白名单</strong>中拿去。</p>\n","prev":{"title":"2021个人年度总结以及感想","link":"2021/10/31/2021个人年度总结以及感想"},"next":{"title":"TCP协议","link":"2021/08/14/TCP协议"},"plink":"http://hongweichen.github.io/2021/08/16/HTTP协议/","toc":[{"id":"http的特性","title":"HTTP的特性","index":"1"},{"id":"http报文","title":"HTTP报文","index":"2","children":[{"id":"请求报文","title":"请求报文","index":"2.1"}]},{"id":"post提交数据的方式","title":"POST提交数据的方式","index":"3"},{"id":"响应报文","title":"响应报文","index":"4"},{"id":"条件get","title":"条件GET","index":"5"},{"id":"持久连接","title":"持久连接","index":"6"},{"id":"transfer-encoding","title":"Transfer-Encoding","index":"7"},{"id":"http-pipelining（http管线化）","title":"HTTP Pipelining（HTTP管线化）","index":"8"},{"id":"会话跟踪","title":"会话跟踪","index":"9"},{"id":"会话跟踪常用的方法","title":"会话跟踪常用的方法","index":"10"},{"id":"跨站攻击","title":"跨站攻击","index":"11"}],"reading_time":"5744 words in 38 min"}