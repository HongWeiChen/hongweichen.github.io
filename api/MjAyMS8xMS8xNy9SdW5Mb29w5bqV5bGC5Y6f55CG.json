{"title":"深入理解RunLoop","date":"2021-11-16T16:00:00.000Z","date_formatted":{"ll":"Nov 17, 2021","L":"11/17/2021","MM-DD":"11-17"},"link":"2021/11/17/RunLoop底层原理","tags":["Runloop"],"updated":"2022-03-02T14:17:46.711Z","content":"<p>RunLoop是iOS和OSX开发中非常基础的一个概念，这篇文章将从CFRunLoop的源码入手，介绍RunLoop的概念以及底层实现原理。之后介绍一下在iOS中，苹果是如何利用RunLoop实现自动释放池、延迟回调、触摸实现、屏幕刷新等功能的。</p>\n<h1 id=\"runloop的概念\">RunLoop的概念<a title=\"#runloop的概念\" href=\"#runloop的概念\"></a></h1>\n<p>一般来讲，一个线程一次只能执行一个任务，执行完后线程就会退出。如果我们需要一个机制，让线程随时处理事件并不退出，通常的代码逻辑是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loop() &#123;</span><br><span class=\"line\">  initialize();</span><br><span class=\"line\">  do &#123;</span><br><span class=\"line\">    var message = get_next_message();</span><br><span class=\"line\">    process_message(message);</span><br><span class=\"line\">  &#125; while(message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种模型通常被称作Event Loop。Event Loop在很多系统和框架都有实现，比如Node.js的事件处理，比如Windows程序的消息循环，在比如OSX/iOS里的RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠避免占用资源、在有消息到来时立刻被唤醒。</p>\n<p>所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面Event Loop的逻辑。线程执行了这个函数后，就会一直处于这个函数内部“接受消息-&gt;等待-&gt;处理”的循环中，直到这个循环结束（比如传入quit消息），函数返回。</p>\n<p>OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。<br>\nCFRunLoopRef是在CoreFoundation框架内的，它提供了纯C函数的API，所有这些API都是线程安全的。<br>\nNSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，但是这些API不是线程安全的。</p>\n<p>CFRunLoop的代码是开源的，你可以在这里(<a href=\"http://opensource.apple.com/tarballs/CF/\">http://opensource.apple.com/tarballs/CF/</a>)下载到整个CoreFoundation的源码来查看。</p>\n<p>(Update：Swift开源后，苹果又维护了一个跨平台的CoreFoundation版本：<a href=\"https://github.com/apple/swift-corelibs-foundation/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E7%A0%81%E5%8F%AF%E8%83%BD%E5%92%8C%E7%8E%B0%E6%9C%89%E7%9A%84iOS%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%95%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%BD%86%E6%9B%B4%E5%AE%B9%E6%98%93%E7%BC%96%E8%AF%91%EF%BC%8C%E8%80%8C%E4%B8%94%E5%B7%B2%E7%BB%8F%E9%80%82%E9%85%8DLinux/Windows\">https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有的iOS系统中的实现略不一样，但更容易编译，而且已经适配Linux/Windows</a>)</p>\n<h1 id=\"runloop与线程的关系\">RunLoop与线程的关系<a title=\"#runloop与线程的关系\" href=\"#runloop与线程的关系\"></a></h1>\n<p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>\n<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class=\"line\">static CFMutableDictionaryRef loopsDic;</span><br><span class=\"line\">/// 访问 loopsDic 时的锁</span><br><span class=\"line\">static CFSpinLock_t loopsLock;</span><br><span class=\"line\"></span><br><span class=\"line\">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class=\"line\">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    OSSpinLockLock(&amp;loopsLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!loopsDic) &#123;</span><br><span class=\"line\">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class=\"line\">        loopsDic = CFDictionaryCreateMutable();</span><br><span class=\"line\">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class=\"line\">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// 直接从 Dictionary 里获取。</span><br><span class=\"line\">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!loop) &#123;</span><br><span class=\"line\">        /// 取不到时，创建一个</span><br><span class=\"line\">        loop = _CFRunLoopCreate();</span><br><span class=\"line\">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class=\"line\">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class=\"line\">    return loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class=\"line\">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class=\"line\">    return _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h1 id=\"runloop-对外的接口\">RunLoop 对外的接口<a title=\"#runloop-对外的接口\" href=\"#runloop-对外的接口\"></a></h1>\n<p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<p>CFRunLoopRef<br>\nCFRunLoopModeRef<br>\nCFRunLoopSourceRef<br>\nCFRunLoopTimerRef<br>\nCFRunLoopObserverRef</p>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>\n<p><a href=\"#https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png\"></a></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<br>\n• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br>\n• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p>\n<p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>\n<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class=\"line\">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>\n<h1 id=\"runloop-的-mode\">RunLoop 的 Mode<a title=\"#runloop-的-mode\" href=\"#runloop-的-mode\"></a></h1>\n<p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __CFRunLoopMode &#123;</span><br><span class=\"line\">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class=\"line\">    CFMutableSetRef _sources0;    // Set</span><br><span class=\"line\">    CFMutableSetRef _sources1;    // Set</span><br><span class=\"line\">    CFMutableArrayRef _observers; // Array</span><br><span class=\"line\">    CFMutableArrayRef _timers;    // Array</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct __CFRunLoop &#123;</span><br><span class=\"line\">    CFMutableSetRef _commonModes;     // Set</span><br><span class=\"line\">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class=\"line\">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class=\"line\">    CFMutableSetRef _modes;           // Set</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>\n<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>\n<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>\n","prev":{"title":"React-Native中常用的命令","link":"2021/12/15/React-Native常用命令"},"next":{"title":"MRC下retain所影响retainCount的变化","link":"2021/11/15/MRC下retain所影响retainCount的变化"},"plink":"http://hongweichen.github.io/2021/11/17/RunLoop底层原理/","toc":[{"id":"runloop的概念","title":"RunLoop的概念","index":"1"},{"id":"runloop与线程的关系","title":"RunLoop与线程的关系","index":"2"},{"id":"runloop-对外的接口","title":"RunLoop 对外的接口","index":"3"},{"id":"runloop-的-mode","title":"RunLoop 的 Mode","index":"4"}],"reading_time":"1933 words in 13 min"}