{"title":"Objective-C NSObject","date":"2021-11-07T16:00:00.000Z","date_formatted":{"ll":"Nov 8, 2021","L":"11/08/2021","MM-DD":"11-08"},"link":"2021/11/08/Objective-C NSObject","tags":["Objective-C"],"updated":"2022-03-05T07:30:30.045Z","content":"<h1 id=\"nsobject\">NSObject<a title=\"#nsobject\" href=\"#nsobject\"></a></h1>\n<p>我们经常使用<code>[[NSObject alloc] init]</code>这类的方法</p>\n<p>今天就来研究一下NSObject初始化底层的实现</p>\n<p>首先看下alloc这个方法都做了什么，在很多网站都看多类似于对alloc的说明，就是开辟了一块内存空间，那具体是怎么调用？</p>\n<p><strong><a href=\"http://NSObject.mm\">NSObject.mm</a></strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (id)alloc &#123;</span><br><span class=\"line\">    return _objc_rootAlloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Base class implementation of +alloc. cls is not nil.</span><br><span class=\"line\">// Calls [cls allocWithZone:nil].</span><br><span class=\"line\">id</span><br><span class=\"line\">_objc_rootAlloc(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate</span><br><span class=\"line\">// shortcutting optimizations.</span><br><span class=\"line\">static ALWAYS_INLINE id</span><br><span class=\"line\">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#if __OBJC2__</span><br><span class=\"line\">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class=\"line\">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class=\"line\">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    // No shortcuts available.</span><br><span class=\"line\">    if (allocWithZone) &#123;</span><br><span class=\"line\">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"调用过程\">调用过程<a title=\"#调用过程\" href=\"#调用过程\"></a></h1>\n<blockquote>\n<p>alloc -&gt; _objc_rootAlloc -&gt; callAlloc</p>\n</blockquote>\n<p>在callAlloc中，有slowpath和fastpath两个判断的方法，slowpath和fastpath是封装的两个宏定义。</p>\n<p>在objc-os文件中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define fastpath(x) (__builtin_expect(bool(x), 1))</span><br><span class=\"line\">#define slowpath(x) (__builtin_expect(bool(x), 0))</span><br></pre></td></tr></table></figure>\n<p>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：__builtin_expect(EXP, N)<br>\n意思是：EXP==N的概率很大</p>\n<p>一般使用方法是将__builtin_expect指令封装为liekly和unlikely宏。</p>\n<p>在llvm-DenseMap文件中，也可以看到封装的两个宏定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define LLVM_UNLIKELY slowpath</span><br><span class=\"line\">#define LLVM_LIKELY fastpath</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fastpath(x)表示x值为真的可能性更大</li>\n<li>slowpath(x)表示x值为假的可能性更大</li>\n</ul>\n<p>通过这种方式，编译器在编译过程中，会将可能性更大的代码紧跟着前面的代码，从而减少指令跳转带来的性能上的下降。</p>\n<h1 id=\"例\">例<a title=\"#例\" href=\"#例\"></a></h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x, y;</span><br><span class=\"line\">if (fastpath(x &gt; 0)) &#123;</span><br><span class=\"line\">  y = 1</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  y = -1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>gcc编译的指令会预先读取y=1这条指令，一般这么写适合x值大于0的概率比较高的情况。如果x值&lt;0的概率比较高，则使用slowpath(x)。这样编译器指令就会预先读取y = -1。<br>\n这样系统就可以在运行时减少重新取值了。</p>\n<p>待续</p>\n","prev":{"title":"Objective-C NSString","link":"2021/11/09/Objective-C NSString"},"next":{"title":"动态、静态、强类型、弱类型","link":"2021/11/07/动态、静态、强类型、弱类型"},"plink":"http://hongweichen.github.io/2021/11/08/Objective-C NSObject/","toc":[{"id":"nsobject","title":"NSObject","index":"1"},{"id":"调用过程","title":"调用过程","index":"2"},{"id":"例","title":"例","index":"3"}],"reading_time":"545 words in 4 min"}