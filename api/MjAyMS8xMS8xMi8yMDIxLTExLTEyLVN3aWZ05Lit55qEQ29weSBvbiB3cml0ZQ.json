{"title":"Swift中的Copy on write","date":"2021-11-11T16:00:00.000Z","date_formatted":{"ll":"Nov 12, 2021","L":"11/12/2021","MM-DD":"11-12"},"author":"HongWeiChen","link":"2021/11/12/2021-11-12-Swift中的Copy on write","tags":["Swift"],"updated":"2021-11-15T07:40:38.000Z","content":"<h1 id=\"写时复制\">写时复制<a title=\"#写时复制\" href=\"#写时复制\"></a></h1>\n<p>在Swift中，结构体有着相当重要的地位，在Swift标准库中，大约有90%的公开类型都是结构体，包括我们常用的Array、Dictionary、String。结构体相比类，一个最重要的特征就是它的值类型，而类似引用类型。值类型是通过复制来赋值的，而不是引用同一个地址，这就不存在数据共享的问题，能防止意外的数据改变，并且它是线程安全的。</p>\n<p>举一个简单的例子，在objc中，数据是类，是引用类型，在Swift中，是结构体，是值类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *array = @[&quot;zhangsan&quot;, &quot;lisi&quot;].mutableCopy;</span><br><span class=\"line\">NSMutableArray *array2 = array;</span><br><span class=\"line\">[array addObject:@&quot;wangwu&quot;];</span><br></pre></td></tr></table></figure>\n<p>array和array2都变成了[“zhangsan”, “list”, “wangwu”]也就是array的改变会导致array2的改变，因为他们都是引用类型，并且都引用了相同的一块内存地址。</p>\n<p>而在Swift中，就不会存在这样的问题</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array <span class=\"operator\">=</span> [<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"string\">&quot;lisi&quot;</span>]</span><br><span class=\"line\">array2 <span class=\"operator\">=</span> array</span><br><span class=\"line\">array.append(<span class=\"string\">&quot;wangwu&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>在Swift中，array是[“zhangsan”, “lisi”, “wangwu”]，而array2还是[“zhangsan”, “lisi”]，这就是结构体和类的最大区别。</p>\n<p>那么，是不是每次将struct赋值给到其他变量或者传递函数时都会发生复制呢。答案是否定的，在Swift中Array、Dictionary、String这些类型中，尽管他们都是值类型，但在Swift的具体实现中做了优化，可避免不必要的复制。在《The Swift Programming Language(Swift2.2)》一书中的“Classes and Structures”一章末尾写到：</p>\n<blockquote>\n<p>The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.</p>\n</blockquote>\n<p>在Swift中采用的优化方式叫写时复制，简单的说就是，只有当一个结构体发生了写入的动作时才会有复制的行为。具体的做法就是，在结构体内部用一个引用类型来存储实际的数据，在不进行写入操作的普通传递中，都是将内部的reference引用计数+1，在进行写入操作时，对内部的reference做一次copy操作用来存储新的数据，防止和之前的reference产生意外的数据共享。</p>\n<p>在Swift中有一个方法：<code>isUniquelyRefrencedNonObjC</code>(Swift 2.2)，在Swift3中这个函数变成了：<code>isKnownUniquelyReferenced</code>，他能检查一个类的实例是不是唯一的引用，如果是，我们就不需要对结构体的实例进行复制，如果不是，就说明被不同的结构体共享，这时对他进行修改就需要进行复制。</p>\n<p>这个函数只对Swift对象有效，如果要用在Objective-C对象上，可以对Objective对象用Swift进行一次封装。</p>\n<p>下面是《Advanced Swift》书中的一个写时复制技术的代码实例</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">A</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> unbox: <span class=\"type\">A</span></span><br><span class=\"line\">  <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> <span class=\"params\">value</span>: <span class=\"type\">A</span>) &#123;</span><br><span class=\"line\">    unbox <span class=\"operator\">=</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GaussianBlur</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> boxedFilter: <span class=\"type\">Box</span>&lt;<span class=\"type\">CIFilter</span>&gt; <span class=\"operator\">=</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> filter <span class=\"operator\">=</span> <span class=\"type\">CIFilter</span>(name: <span class=\"string\">&quot;CIGaussianBlur&quot;</span>, withInputParameters: [:])<span class=\"operator\">!</span></span><br><span class=\"line\">    filter.setDefaults()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">Box</span>(filter)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">var</span> filter: <span class=\"type\">CIFilter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> boxedFilter.unbox &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> &#123; boxedFilter <span class=\"operator\">=</span> <span class=\"type\">Box</span>(newValue) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> filterForWriting: <span class=\"type\">CIFilter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"operator\">!</span><span class=\"built_in\">isKnownUniquelyReferenced</span>(<span class=\"operator\">&amp;</span>boxedFilter) &#123;</span><br><span class=\"line\">        filter <span class=\"operator\">=</span> filter.copy() <span class=\"keyword\">as!</span> <span class=\"type\">CIFilter</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> filter</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> inputImage: <span class=\"type\">CIImage</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> filter.value(forKey: kCIInputImageKey) <span class=\"keyword\">as!</span> <span class=\"type\">CIImage</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> &#123; filterForWriting.setValue(newValue, forKey: kCIInputImageKey) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> radius: <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> filter.value(forKey: kCIInputRadiusKey) <span class=\"keyword\">as!</span> <span class=\"type\">Double</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> &#123; filterForWriting.setValue(newValue, forKey: kCIInputRadiusKey) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">GaussianBlur</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> outputImage: <span class=\"type\">CIImage</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filter.outputImage</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"iOS中weak的底层原理","link":"2021/11/15/2021-11-15-iOS中weak的底层原理"},"next":{"title":"JavaScript中柯里化（函数化编程）","link":"2021/11/11/2021-11-11-详解JavaScript柯里化（函数化编程）"},"plink":"http://hongweichen.github.io/2021/11/12/2021-11-12-Swift中的Copy on write/","toc":[{"id":"写时复制","title":"写时复制","index":"1"}],"reading_time":"880 words in 6 min"}